<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Coryphaei技术博客]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.coryphaei.com/"/>
  <updated>2016-01-06T15:42:18.000Z</updated>
  <id>http://blog.coryphaei.com/</id>
  
  <author>
    <name><![CDATA[coryphaei]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Objective-C封装技巧（三）：比继承更加灵活的overwrite方法 -- Method Swizzling]]></title>
    <link href="http://blog.coryphaei.com/2016/01/06/Objective-C%E5%B0%81%E8%A3%85%E6%8A%80%E5%B7%A7%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%AF%94%E7%BB%A7%E6%89%BF%E6%9B%B4%E5%8A%A0%E7%81%B5%E6%B4%BB%E7%9A%84overwrite%E6%96%B9%E6%B3%95%20--%20Method%20Swizzling/"/>
    <id>http://blog.coryphaei.com/2016/01/06/Objective-C封装技巧（三）：比继承更加灵活的overwrite方法 -- Method Swizzling/</id>
    <published>2016-01-06T02:38:24.000Z</published>
    <updated>2016-01-06T15:42:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>有经验的工程师在经历过一些项目之后，会慢慢的去考虑之前项目中遇到的坑，思考的过程中就会诞生设计模式和架构的雏形。我这次毕业设计的项目架构正在酝酿中，因为自己本身经验并没有很丰富，所以浅谈自己封装的一些想法，权当抛砖引玉。</p>
<p>平时项目中我们经常会对重复使用的代码进行封装，那么对于封装的场景是否有过思考？是否想过各种封装方法的使用场景和原则。我们实现提出在封装常用的方法：继承和Category。另外在继承的基础上我们发现了比继承更加灵活的Swizzling和在Category的使用过程出现的Associated Objects。关于上述的所有方法，我将会写一个系列来阐述。</p>
<ul>
<li><a href="">Objective-C封装技巧（一）：Category和继承的博弈</a></li>
<li><a href="">Objective-C封装技巧（二）：与“魔鬼的交易” – Associated Objects</a></li>
<li><a href="">Objective-C封装技巧（三）：比继承更加灵活的overwrite方法 – Method Swizzling</a></li>
</ul>
<h1 id="u63D0_u51FA_u95EE_u9898"><a href="#u63D0_u51FA_u95EE_u9898" class="headerlink" title="提出问题"></a>提出问题</h1><p>希望大家在看系列文章之前，首先思考下面提出的几个问题：</p>
<ol>
<li>对于方法封装，我们平时经常使用的就是继承子类化Base基类和使用Category，那么在使用这两个方法是具体场景是什么？它们之前的区别和使用优先原则是什么？</li>
<li>Category不允许自定义实例属性的缺点，可以用什么来弥补？（提示：Associated Objects）Associated Objects的具体使用场景又是什么呢？</li>
<li>对于需要重复写的通用方法，又存在生命周期中的方法，除了工厂方法继承多个工厂类，还有没有更好的封装机制？（提示：Method Swizzling）关于Method Swizzling的使用场景和机制是什么？<br>本篇博客对第三个问题进行回答分析，如果阐述过程中有错误或者疑问，大家可以在文章下面留言。</li>
</ol>
<p><a href="http://blog.leichunfeng.com/blog/2015/06/14/objective-c-method-swizzling-best-practice/" target="_blank" rel="external">http://blog.leichunfeng.com/blog/2015/06/14/objective-c-method-swizzling-best-practice/</a><br><a href="http://blog.csdn.net/yiyaaixuexi/article/details/9374411" target="_blank" rel="external">http://blog.csdn.net/yiyaaixuexi/article/details/9374411</a><br><a href="http://nshipster.com/method-swizzling/" target="_blank" rel="external">http://nshipster.com/method-swizzling/</a><br><a href="http://southpeak.github.io/blog/2014/11/06/objective-c-runtime-yun-xing-shi-zhi-si-:method-swizzling/" target="_blank" rel="external">http://southpeak.github.io/blog/2014/11/06/objective-c-runtime-yun-xing-shi-zhi-si-:method-swizzling/</a><br><a href="http://tech.glowing.com/cn/method-swizzling-aop/" target="_blank" rel="external">http://tech.glowing.com/cn/method-swizzling-aop/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>有经验的工程师在经历过一些项目之后，会慢慢的去考]]>
    </summary>
    
      <category term="Objective-C" scheme="http://blog.coryphaei.com/tags/Objective-C/"/>
    
      <category term="Swizzling" scheme="http://blog.coryphaei.com/tags/Swizzling/"/>
    
      <category term="iOS" scheme="http://blog.coryphaei.com/tags/iOS/"/>
    
      <category term="封装" scheme="http://blog.coryphaei.com/tags/%E5%B0%81%E8%A3%85/"/>
    
      <category term="叶帆" scheme="http://blog.coryphaei.com/categories/%E5%8F%B6%E5%B8%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Objective-C封装技巧（二）：与“魔鬼的交易” -- Associated Objects]]></title>
    <link href="http://blog.coryphaei.com/2016/01/06/Objective-C%E5%B0%81%E8%A3%85%E6%8A%80%E5%B7%A7%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%B8%8E%E2%80%9C%E9%AD%94%E9%AC%BC%E7%9A%84%E4%BA%A4%E6%98%93%E2%80%9D%20--%20Associated%20Objects/"/>
    <id>http://blog.coryphaei.com/2016/01/06/Objective-C封装技巧（二）：与“魔鬼的交易” -- Associated Objects/</id>
    <published>2016-01-06T01:42:32.000Z</published>
    <updated>2016-01-06T15:42:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>有经验的工程师在经历过一些项目之后，会慢慢的去考虑之前项目中遇到的坑，思考的过程中就会诞生设计模式和架构的雏形。我这次毕业设计的项目架构正在酝酿中，因为自己本身经验并没有很丰富，所以浅谈自己封装的一些想法，权当抛砖引玉。</p>
<p>平时项目中我们经常会对重复使用的代码进行封装，那么对于封装的场景是否有过思考？是否想过各种封装方法的使用场景和原则。我们实现提出在封装常用的方法：继承和Category。另外在继承的基础上我们发现了比继承更加灵活的Swizzling和在Category的使用过程出现的Associated Objects。关于上述的所有方法，我将会写一个系列来阐述。</p>
<ul>
<li><a href="">Objective-C封装技巧（一）：Category和继承的博弈</a></li>
<li><a href="">Objective-C封装技巧（二）：与“魔鬼的交易” – Associated Objects</a></li>
<li><a href="">Objective-C封装技巧（三）：比继承更加灵活的overwrite方法 – Method Swizzling</a></li>
</ul>
<h1 id="u63D0_u51FA_u95EE_u9898"><a href="#u63D0_u51FA_u95EE_u9898" class="headerlink" title="提出问题"></a>提出问题</h1><p>希望大家在看系列文章之前，首先思考下面提出的几个问题：</p>
<ol>
<li>对于方法封装，我们平时经常使用的就是继承子类化Base基类和使用Category，那么在使用这两个方法是具体场景是什么？它们之前的区别和使用优先原则是什么？</li>
<li>Category不允许自定义实例属性的缺点，可以用什么来弥补？（提示：Associated Objects）Associated Objects的具体使用场景又是什么呢？</li>
<li>对于需要重复写的通用方法，又存在生命周期中的方法，除了工厂方法继承多个工厂类，还有没有更好的封装机制？（提示：Method Swizzling）关于Method Swizzling的使用场景和机制是什么？<br>本篇博客对第二个问题进行回答分析，如果阐述过程中有错误或者疑问，大家可以在文章下面留言。</li>
</ol>
<h1 id="Associated_Objects"><a href="#Associated_Objects" class="headerlink" title="Associated Objects"></a>Associated Objects</h1><p>我们知道上次再写Category的时候提到了Category的缺点，不能自定义实例变量。我们在上篇博客的中给出的答案是可以考虑继承，这里引入一个新的技术方案 – Associated Objects。</p>
<h2 id="u524D_u63D0"><a href="#u524D_u63D0" class="headerlink" title="前提"></a>前提</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>首先需要导入runtime这个类，runtime是个双刃剑。大家使用的时候一定要小心。Associated Objects就是其中一个利器。<br>有关于runtime，可以参考下Apple官方的<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/ObjCRuntimeRef/#//apple_ref/c/func/objc_setAssociatedObject" target="_blank" rel="external">文档</a>。</p>
<h2 id="u5F00_u59CB"><a href="#u5F00_u59CB" class="headerlink" title="开始"></a>开始</h2><p>Associated Objects弥补了Objective-C不能在存在的类中扩展自定义属性的缺点，非常的便捷。Associated Objects（对相关联），用一句通俗的话来概括下就是将键值对在运行是关联到对象函数。<br>一共三个方法：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key, id <span class="keyword">value</span>, objc_AssociationPolicy policy</span>)</span>;</span><br><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_removeAssociatedObjects</span>(<span class="params">id <span class="keyword">object</span></span>)</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="u521B_u5EFA_u5173_u8054"><a href="#u521B_u5EFA_u5173_u8054" class="headerlink" title="创建关联"></a>创建关联</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key, id <span class="keyword">value</span>, objc_AssociationPolicy policy</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>一共需要四个参数：源对象，关键字，关联的对象和一个关联策略。我们一一解释。</p>
<ul>
<li><strong>object</strong> 源对象：需要进行关联的对象。                                                                        </li>
<li><strong>key</strong> 关键字：关键字是一个void类型的指针。每一个关联的关键字必须是唯一的。有三种方式来进行关键的定义，下面会给出。      </li>
<li><strong>value</strong> 关联的对象：在Catogory中一般就是自定义的变量。                                                         </li>
<li><strong>policy</strong> 关联策略：相关的对象是通过赋值，保留引用还是复制的方式、通过原子还是非原子的方式进行关联。一共有五种方式，下面给出。</li>
</ul>
<h3 id="key-_u5173_u952E_u5B57_u5B9A_u4E49"><a href="#key-_u5173_u952E_u5B57_u5B9A_u4E49" class="headerlink" title="key-关键字定义"></a>key-关键字定义</h3><ol>
<li>声明 <strong>static char kAssociatedObjectKey;</strong> ，使用 <strong>&amp;kAssociatedObjectKey</strong> 作为key值;</li>
<li>声明 <strong>static void *kAssociatedObjectKey = &kAssociatedObjectKey;</strong>，使用 <strong>kAssociatedObjectKey</strong> 作为key值；</li>
<li>使用 <strong>selector</strong> ，使用getter方法的名称 <strong>@selector(associatedObject)</strong> 作为 key 值。</li>
</ol>
<p>通常使用 <strong>static char</strong> 类型来定义，更加推荐的是指针类型。另外，尽量保证该属性是常量且唯一，试用范围在本类当中。当然有的人喜欢 <strong>selector</strong> 的方式，因为解决了计算机中最难的取名字问题。</p>
<h3 id="policy-_u5173_u8054_u5BF9_u8C61_u7684_u884C_u4E3A"><a href="#policy-_u5173_u8054_u5BF9_u8C61_u7684_u884C_u4E3A" class="headerlink" title="policy-关联对象的行为"></a>policy-关联对象的行为</h3><table>
<thead>
<tr>
<th>Behavior</th>
<th style="text-align:center">@property</th>
<th style="text-align:right">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJC_ASSOCIATION_ASSIGN</td>
<td style="text-align:center">@property (assign)</td>
<td style="text-align:right">指定一个关联对象的弱引用。</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>
<td style="text-align:center">@property (nonatomic, strong)</td>
<td style="text-align:right">指定一个关联对象的强引用，不能被原子化使用。</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY_NONATOMIC</td>
<td style="text-align:center">@property (nonatomic, copy)</td>
<td style="text-align:right">指定一个关联对象的copy引用，不能被原子化使用。</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN</td>
<td style="text-align:center">@property (atomic, strong)</td>
<td style="text-align:right">指定一个关联对象的强引用，能被原子化使用。</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY</td>
<td style="text-align:center">@property (atomic, copy)</td>
<td style="text-align:right">指定一个关联对象的copy引用，能被原子化使用。</td>
</tr>
</tbody>
</table>
<h2 id="u83B7_u53D6_u5173_u8054"><a href="#u83B7_u53D6_u5173_u8054" class="headerlink" title="获取关联"></a>获取关联</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>这个非常简单，不再赘述。</p>
<h2 id="u65AD_u5F00_u5173_u8054"><a href="#u65AD_u5F00_u5173_u8054" class="headerlink" title="断开关联"></a>断开关联</h2><p>理论上说，我们会使用 <strong>void objc_removeAssociatedObjects(id object);</strong> 但是我们不应手动去调用这个函数。</p>
<blockquote>
<p>此函数的主要目的是在“初试状态”时方便地返回一个对象。你不应该用这个函数来删除对象的属性，因为可能会导致其他客户对其添加的属性也被移除了。规范的方法是：调用 objc_setAssociatedObject 方法并传入一个 nil 值来清除一个关联。</p>
</blockquote>
<p>通常这样去断开关联<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_setAssociatedObject<span class="list">(<span class="keyword">array</span>, <span class="keyword">&amp;overviewKey</span>, <span class="literal">nil</span>, OBJC_ASSOCIATION_ASSIGN)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="u751F_u547D_u5468_u671F"><a href="#u751F_u547D_u5468_u671F" class="headerlink" title="生命周期"></a>生命周期</h2><blockquote>
<p>根据 WWDC 2011, Session 322 (第36分22秒) 中发布的内存销毁时间表，被关联的对象在生命周期内要比对象本身释放的晚很多。它们会在被 NSObject -dealloc 调用的 object_dispose() 方法中释放。</p>
<p>关联对象的释放时机与移除时机并不总是一致，比如实验中用关联策略 OBJC_ASSOCIATION_ASSIGN 进行关联的对象，很早就已经被释放了，但是并没有被移除，而再使用这个关联对象时就会造成 Crash 。</p>
</blockquote>
<h1 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h1><p>对于Associated Objects，提供一种为Category添加自定义属性的方法。那么，在我们有自定义属性的时候，我们去使用继承还是使用Associated Objects呢？<a href="https://github.com/ibireme" target="_blank" rel="external">Yaoyuan</a>大神在issue中这样回复我：<br><img src="http://7xkvt5.com1.z0.glb.clouddn.com/package%2FAssociatedObjects.png" alt="比较"></p>
<p>所以大家还是根据自己的使用场景去确定，最后一个问题将在下篇博客中进行讲解。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>有经验的工程师在经历过一些项目之后，会慢慢的去考]]>
    </summary>
    
      <category term="Objective-C" scheme="http://blog.coryphaei.com/tags/Objective-C/"/>
    
      <category term="category" scheme="http://blog.coryphaei.com/tags/category/"/>
    
      <category term="iOS" scheme="http://blog.coryphaei.com/tags/iOS/"/>
    
      <category term="runtime" scheme="http://blog.coryphaei.com/tags/runtime/"/>
    
      <category term="叶帆" scheme="http://blog.coryphaei.com/categories/%E5%8F%B6%E5%B8%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Objective-C封装技巧（一）：Category和继承的博弈]]></title>
    <link href="http://blog.coryphaei.com/2016/01/05/Objective-C%E5%B0%81%E8%A3%85%E6%8A%80%E5%B7%A7%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ACategory%E5%92%8C%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8D%9A%E5%BC%88/"/>
    <id>http://blog.coryphaei.com/2016/01/05/Objective-C封装技巧（一）：Category和继承的博弈/</id>
    <published>2016-01-05T07:24:19.000Z</published>
    <updated>2016-01-06T15:42:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>有经验的工程师在经历过一些项目之后，会慢慢的去考虑之前项目中遇到的坑，思考的过程中就会诞生设计模式和架构的雏形。我这次毕业设计的项目架构正在酝酿中，因为自己本身经验并没有很丰富，所以浅谈自己封装的一些想法，权当抛砖引玉。</p>
<p>平时项目中我们经常会对重复使用的代码进行封装，那么对于封装的场景是否有过思考？是否想过各种封装方法的使用场景和原则。我们实现提出在封装常用的方法：继承和Category。另外在继承的基础上我们发现了比继承更加灵活的Swizzling和在Category的使用过程出现的Associated Objects。关于上述的所有方法，我将会写一个系列来阐述。</p>
<ul>
<li><a href="">Objective-C封装技巧（一）：Category和继承的博弈</a></li>
<li><a href="">Objective-C封装技巧（二）：与“魔鬼的交易” – Associated Objects</a></li>
<li><a href="">Objective-C封装技巧（三）：比继承更加灵活的overwrite方法 – Method Swizzling</a></li>
</ul>
<h1 id="u63D0_u51FA_u95EE_u9898"><a href="#u63D0_u51FA_u95EE_u9898" class="headerlink" title="提出问题"></a>提出问题</h1><p>希望大家在看系列文章之前，首先思考下面提出的几个问题：</p>
<ol>
<li>对于方法封装，我们平时经常使用的就是继承子类化Base基类和使用Category，那么在使用这两个方法是具体场景是什么？它们之前的区别和使用优先原则是什么？</li>
<li>Category不允许自定义实例属性的缺点，可以用什么来弥补？（提示：Associated Objects）Associated Objects的具体使用场景又是什么呢？</li>
<li>对于需要重复写的通用方法，又存在生命周期中的方法，除了工厂方法继承多个工厂类，还有没有更好的封装机制？（提示：Method Swizzling）关于Method Swizzling的使用场景和机制是什么？<br>本篇博客对第一个问题进行回答分析，如果阐述过程中有错误或者疑问，大家可以在文章下面留言。</li>
</ol>
<h1 id="u7EE7_u627F_u2013_u5B50_u7C7B_u5316"><a href="#u7EE7_u627F_u2013_u5B50_u7C7B_u5316" class="headerlink" title="继承–子类化"></a>继承–子类化</h1><p>我们首先从继承–对面对象的三大基本特征讲起，继承的概念得益于能够方便的对父类的方法进行实现和overwrite。在使用场景上，我想很多开发者应该在项目之初会经常写了很多Base的基类，封装一些基本的常用方法，在子类中可以直接实用，防止大量的重复代码。下图，使用的是<a href="https://github.com/DeveloperLx" target="_blank" rel="external">DeveloperLx</a>大神的项目框架，特此表示感谢，我也从他的框架中学到了很多。<br><img src="http://7xkvt5.com1.z0.glb.clouddn.com/package%2Fbaseclass.png" alt="baseclass"></p>
<p>应该说所有人的最初封装都是从继承开始，这个是最容易想到的方法。那么这个继承使用的场景其实是在我们需要对方法进行重写的时候（如生命周期等等，当然其实有更好的方法替代），或者对于父类Delegate通用方法来进行封装的时候来使用。但是继承的缺点在于耦合度比较高，比如我们写了BaseViewController来进行继承，那么通用模块移植到别的项目中的时候就会出现依赖于BaseViewController基类的问题。出现了非常高的耦合度，所以我们经常在面试题中，面试官也会问你这样的问题：你项目中使用继承吗？优缺点？是否有改进的方法？</p>
<h1 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h1><p>说到Category，大家肯定不陌生，可以看到Apple官方也大量的使用了Category。Category使用的设计模式其实就是装饰模式，是对于改设计模式的具体实现。Category区别于继承的最大不同点在于，它是在不改变原有类的前提下，动态的去扩展该类的类方法和实例方法。</p>
<h2 id="u4F7F_u7528_u573A_u666F"><a href="#u4F7F_u7528_u573A_u666F" class="headerlink" title="使用场景"></a>使用场景</h2><p>对于Category的使用场景，我们根据<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html#//apple_ref/doc/uid/TP40008195-CH5-SW1" target="_blank" rel="external">Apple</a>官方的描述，可以大致分为以下三类：</p>
<ol>
<li>官方给出的使用最广泛的场景，对一个已经存在的类（不管实现已知还是未知）进行增加方法的扩展，而不去子类化。扩展出来的类均可以被子类和原始类来使用。</li>
<li>把代码量的类中的方法划分成多个Category文件。</li>
<li>声明私有方法。</li>
</ol>
<p>在日常使用的过程中，我们通常使用的是一种方法，因为其封装的便利性，使得其应用非常的广泛。我们使用Category的基本原则：</p>
<blockquote>
<p>“The answer is don’t do that. Only add methods,don’t try to replace or otherwise.It’s hard to understand for people reading your code”</p>
</blockquote>
<p>如果说你在使用的时候发现你试图在Category中去overwrite父类的方法，虽然是可以这么做的，但是不推荐。因为重写之后，在使用方法的时候会优先选择Category中的方法实现，导致原来的方法不能使用。如果出现了这种情况，那么一定是你使用场景出现大的错误，要尝试继承或者其他的封装方法。</p>
<h2 id="u6CE8_u610F"><a href="#u6CE8_u610F" class="headerlink" title="注意"></a>注意</h2><ul>
<li><p>不需要实现所有的方法<br>在我们平时的使用中，在Category中声明的方法并不需要都实现，关键在于你会不会调用方法。</p>
</li>
<li><p>命名<br>开发者在项目的过程中，常常会出现积累了自己Category的情况。当使用三方库的时候，有可能出现Category重名的问题，所以建议大家在创建Category的时候，加上自己特有的prefix。可以在最初使用的时候统一命名为+xxTools，等到Category方法越来越多的时候在进行根据功能划分的Category拆分，当然同时也要加上prefix，避免重名。</p>
</li>
<li><p>属性<br>大家都会说Category中不能自定义属性。这种说法其实是不正确的，在Category中可以声明property，也同样会实现setter和getter方法，但是对于属性的实现是不行的。想要进行弥补，就只能使用Associated Objects来实现。我们将在该系列的下一篇<a href="">博客</a>中来详细展开。</p>
</li>
</ul>
<h2 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h2><p>大家对于Category的封装，可以参考<a href="https://github.com/ibireme" target="_blank" rel="external">Yaoyuan</a>大神的<a href="https://github.com/ibireme/YYCategories" target="_blank" rel="external">YYCategory</a>，直接拿来就能用。对他为开源做出的贡献表示感谢。</p>
<h1 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h1><p>通过上述的展开，我们可以大概总结一下。对于需要重写的父类的方法，或者需要对实例属性进行操作的时候，我们需要选择继承，继承通常应在UIKit的对象中。对于现有类方法的扩展，或者对于Foundation中对象的封装，通常首先考虑使用Category。<br>最后，本篇文章回答了第一次问题，其他的两个问题，将在下面两篇博客中来展开。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>有经验的工程师在经历过一些项目之后，会慢慢的去考]]>
    </summary>
    
      <category term="Category" scheme="http://blog.coryphaei.com/tags/Category/"/>
    
      <category term="Objective-C" scheme="http://blog.coryphaei.com/tags/Objective-C/"/>
    
      <category term="iOS" scheme="http://blog.coryphaei.com/tags/iOS/"/>
    
      <category term="封装" scheme="http://blog.coryphaei.com/tags/%E5%B0%81%E8%A3%85/"/>
    
      <category term="继承" scheme="http://blog.coryphaei.com/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="叶帆" scheme="http://blog.coryphaei.com/categories/%E5%8F%B6%E5%B8%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅谈iOS中Library和Framework]]></title>
    <link href="http://blog.coryphaei.com/2015/12/30/%E6%B5%85%E8%B0%88iOS%E4%B8%ADLibrary%E5%92%8CFramework/"/>
    <id>http://blog.coryphaei.com/2015/12/30/浅谈iOS中Library和Framework/</id>
    <published>2015-12-30T02:40:25.000Z</published>
    <updated>2016-01-04T13:47:25.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>有关于库的出现场景，其实很简单的回答就是，不愿意把实现的源码暴露给其他人。虽然我是脑残的开源爱好者，但是总有些场景下，有这样的需求，比如外包公司的框架，比如我这次写NativeScript，需要自己将三方库打包然后使用在js中调用（当然后来我看到支持CocoaPods的时候，喷了一口老血）。不过这个是客观的一些原因，还有一些有想法的程序员，为了减少编译的时间，也会选择将改动不大的代码进行打包。打包好的代码是编译完成的二进制文件，在项目进行编译的时候链接上，确实一定程度的减少编译时间。</p>
<h1 id="u5E93_u7684_u672C_u8D28"><a href="#u5E93_u7684_u672C_u8D28" class="headerlink" title="库的本质"></a>库的本质</h1><p>库的本质，我觉得非常好理解。我们首先要知道对于所有的库，都是进行编译的，而编译生成的其实是一段二进制代码。所以我们可以给库下个定义：</p>
<blockquote>
<p>提供头文件的编译好的二进制代码。</p>
</blockquote>
<p>对于库的链接，分为了动态链接和静态链接，这也就产生了iOS中的静态库和动态库。</p>
<h1 id="u9759_u6001_u5E93_u548C_u52A8_u6001_u5E93"><a href="#u9759_u6001_u5E93_u548C_u52A8_u6001_u5E93" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h1><p>静态库（Windows 下的 .lib，Linux 和 Mac 下的 .a）。<br>动态库（Windows 下的 .dll，Linux 下的 .so，Mac 下的 .dylib）。</p>
<p>和所有平台所理解静态链接库、动态链接库一样，静态和动态都是相对于编译和运行来讲的：静态库在编译的时候就会被拷贝到目标程序中，运行的时候就不会在改变了；动态库在编译的时候是不会拷贝到目标程序中，在运行的时候会将库加载进来。</p>
<h2 id="u7F16_u8BD1_u548C_u8FD0_u884C"><a href="#u7F16_u8BD1_u548C_u8FD0_u884C" class="headerlink" title="编译和运行"></a>编译和运行</h2><p>区分下编译和运行的概念。在Xcode中我们进行CMD+R的时候其实做了很多的步骤，编译和运行都包括在其中。</p>
<p>编译：如果我们自己打包的时候，使用的是CMD+B的命令，其实是调用了LLVM编译器，进行编译，编程计算机能识别的二进制码。<br>运行：将编译生成的文件链接为可执行文件并进行运行。</p>
<p>静态库就是在目标程序编译的时候已经存在了编译好了的二进制代码，所以说目标程序编译的时候不需要对这段代码进行改变，而且还减少了编译时间。<br>动态库就是在目标程序编译的时候不去链接，而是创建了引用，在运行的时候，进行对动态库的链接和编译。</p>
<h2 id="u4F18_u7F3A_u70B9"><a href="#u4F18_u7F3A_u70B9" class="headerlink" title="优缺点"></a>优缺点</h2><p>静态库的好处很明显，编译完成之后，库文件实际上就没有作用了。目标程序没有外部依赖，直接就可以运行。当然其缺点也很明显，就是会使用目标程序的体积增大。</p>
<p>动态库的优点，不需要拷贝到目标程序中，不会影响目标程序的体积，而且同一份库可以被多个程序使用（因为这个原因，动态库也被称作共享库）。同时，编译时才载入的特性，也可以让我们随时对库进行替换，而不需要重新编译代码，这样就可以实现动态更新。动态库带来的问题主要是，动态载入会带来一部分性能损失，使用动态库也会使得程序依赖于外部环境。如果环境缺少动态库或者库的版本不正确，就会导致程序无法运行。</p>
<h1 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h1><p>Framework是Mac OS/iOS平台特有的一种打包方式，将编译生成的二进制文件、头文件、资源文件统一打包。可以包含如下的东西：</p>
<ul>
<li>共享库</li>
<li>描述API的头文件</li>
<li>文档</li>
<li>资源文件（UI，Assets，配置文件）</li>
</ul>
<p>在iOS 8之前我们Framework其实就是静态库，原因很简单，之前Apple官方不支持动态打包，我们只能使用官方的UIKit或者Foundation等Framework。从iOS 8之后苹果开放了对动态Framework的支持，这应该是苹果为支持 Extension 这一特性而做出的选择（Extension 和 App 是两个分开的可执行文件，它们之间共享代码，所以需要 Framework 支持）。不过我们这个和系统还是有区别，系统的 Framework 不需要拷贝到目标程序中，我们自己做出来的 Framework 哪怕是动态的，最后也还是要拷贝到 App 中，因此苹果又把这种 Framework 称为Embedded Framework。这个时候所谓的动态库其实意义就是升级版的静态库，因为动态库使用的前提是项目在发布前添加到项目中，这和我们所谓的插件（即插即用，随时在自己的服务器上下载一个动态库运行，而不需要重新打包，我们可以选择在需要的时候再加载动态库）完全是两码事。当然我们可以通过方法去实现Framework的动态更新，这里不做赘述。</p>
<h2 id="u521B_u5EFA"><a href="#u521B_u5EFA" class="headerlink" title="创建"></a>创建</h2><p>应该说现在创建一个Framework非常的方便，我们基本上不需要很简单的就能够制作一个Framework。<br>首先我们新建一个Framwork的项目<br><img src="http://7xkvt5.com1.z0.glb.clouddn.com/coryphaei%2Fcreate_framework.png" alt="新建项目"></p>
<p>然后把我们需要创建的文件加入其中，注意这边添加的是Swift的文件，因为Swift中是没有.h和.m的，所以会默认会帮你生成一个xxx-Swift.h的头文件，其中是所有public属性和方法都暴露了出来。<br><img src="http://7xkvt5.com1.z0.glb.clouddn.com/coryphaei%2Fadd_file.png" alt="添加文件"></p>
<h2 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h2><p>接下来应该是有个配置的过程，这边需要详细讲下这些变量是什么意思。</p>
<h3 id="arm"><a href="#arm" class="headerlink" title="arm"></a>arm</h3><p>arm代表的是使用的设备的处理器的型号，大致分为以下几种：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arm64 = iPhone <span class="number">5</span>s, iPad Air, Retina iPad Mini</span><br><span class="line">armv7s = iPhone <span class="number">5</span>, iPhone <span class="number">5</span>c, iPad <span class="number">4</span></span><br><span class="line">armv7  = iPhone <span class="number">3</span>GS, iPhone <span class="number">4</span>, iPhone <span class="number">4</span>S, iPod <span class="number">3</span>G/<span class="number">4</span>G/<span class="number">5</span>G, iPad, iPad <span class="number">2</span>, iPad <span class="number">3</span>, iPad Mini   </span><br><span class="line">i386 = <span class="number">32</span> bit simulator</span><br><span class="line">x86_64 = <span class="number">64</span> bit simulator</span><br></pre></td></tr></table></figure></p>
<h3 id="u51E0_u4E2A_u8BBE_u7F6E"><a href="#u51E0_u4E2A_u8BBE_u7F6E" class="headerlink" title="几个设置"></a>几个设置</h3><p>Architectures：该编译选项指定了工程将被编译成支持哪些指令集，支持指令集是通过编译生成对应的二进制数据包实现的，如果支持的指令集数目有多个，就会编译出包含多个指令集代码的数据包，造成最终编译的包很大。<br>Valid Architectures：该编译项指定可能支持的指令集。<br>最后生成的支持工程的指令集应该是上面两个所产生的交集。</p>
<p>Build Active Architecture Only：该编译项用于设置是否只编译当前使用的设备对应的arm指令集。<br>当这个选项设置为YES的时候，不管Architectures和Valid Architectures设置为什么，最后都只会输出支持当前使用设备对应的arm指令集。<br>通常debug选择YES，release选择NO。</p>
<p>有关于指令集的选择，因为指令集有着向下兼容的特性，所以说为了减少包的大小，我们通常选择只支持armv7，在armv7s和arm64的机器上同样可以使用，当然性能有部分损失，可以忽略不计。<br><img src="http://7xkvt5.com1.z0.glb.clouddn.com/coryphaei%2Fconfig.png" alt="config"></p>
<h2 id="u7F16_u8BD1"><a href="#u7F16_u8BD1" class="headerlink" title="编译"></a>编译</h2><p>有关于编译，一共有两种方式：release和debug。<br>可以手动设置run的方式。<br><img src="http://7xkvt5.com1.z0.glb.clouddn.com/coryphaei%2Fmodify_run.png" alt="modify_run"><br><img src="http://7xkvt5.com1.z0.glb.clouddn.com/coryphaei%2Fmodify_run_release.png" alt="modify_run_release"></p>
<h2 id="u5B8C_u6210"><a href="#u5B8C_u6210" class="headerlink" title="完成"></a>完成</h2><p>Products里面生成了Framework，找到Framework的位置。<br><img src="http://7xkvt5.com1.z0.glb.clouddn.com/coryphaei%2Fframework_finish.png" alt="Fframework_finish"></p>
<h2 id="u5408_u5E76"><a href="#u5408_u5E76" class="headerlink" title="合并"></a>合并</h2><p>接下来应该是需要把模拟器和真机的Framework进行合并，网上应该有脚本，我是直接实用命令行的方式。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lipo -create Debug-iphoneos/SocketIO.framework/SocketIO Debug-iphonesimulator/SocketIO.framework/SocketIO -output SocketIOLib</span><br></pre></td></tr></table></figure></p>
<p>合并完成后进行查看，可以看到支持的指令集。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lipo -info ~/Library/Developer/Xcode/DerivedData/SocketIO-bwzuuvegsamvhtbdwasganalbadg/Build/Products/Debug-iphoneos/SocketIO.framework/SocketIO</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h1><p>有关于库的出现场景，其实很简单的回答就是，不愿意]]>
    </summary>
    
      <category term="Framework" scheme="http://blog.coryphaei.com/tags/Framework/"/>
    
      <category term="Objective-C" scheme="http://blog.coryphaei.com/tags/Objective-C/"/>
    
      <category term="Swift" scheme="http://blog.coryphaei.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://blog.coryphaei.com/tags/iOS/"/>
    
      <category term="叶帆" scheme="http://blog.coryphaei.com/categories/%E5%8F%B6%E5%B8%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Html5表单验证在ajax提交时失效的处理]]></title>
    <link href="http://blog.coryphaei.com/2015/12/24/Html5%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/"/>
    <id>http://blog.coryphaei.com/2015/12/24/Html5表单验证/</id>
    <published>2015-12-24T08:24:24.000Z</published>
    <updated>2016-01-04T13:47:25.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u95EE_u9898_u63CF_u8FF0"><a href="#u95EE_u9898_u63CF_u8FF0" class="headerlink" title="问题描述"></a>问题描述</h3><p>html5为我们提供了强大的校验功能，这无疑为我们手动写验证或者使用JQueryValide要方便的多，这里我们并不去缀述html5的自动校验功能，我们来说一下在ajax提交form表单的情况下验证失效的问题。众所周知，form表单的提交是带跳转的，如果不想刷新或者跳转页面的话，我们必须使用ajax来提交表单数据，这样的话又会带来一个问题，就是form表单的校验就会失效，这样的话html5强大的验证功能我们就失去了，怎么来解决这个办法呢？</p>
<h3 id="u95EE_u9898_u5206_u6790"><a href="#u95EE_u9898_u5206_u6790" class="headerlink" title="问题分析"></a>问题分析</h3><p>我们知道，html5中form表单验证的触发是在表单提交的时候，在html中提交表单只需有个type=submit的button，在点击该button之后，便会触发表单验证以及向远端提交数据。一般情况下，我们在使用ajax提交表单的时候，坚听了一个type=button的button的点击事件，然后向远端传递一个序列化的表单数据，从始至终我们都没有看到form的submit()事件的触发，这是为什么我们表单验证失效的原因。</p>
<p>这样，我们就有了解决问题的思路，我们能不能触发submit事件，同时又阻止form表单提交数据并跳转呢。答案是可以的。</p>
<h3 id="u89E3_u51B3_u95EE_u9898"><a href="#u89E3_u51B3_u95EE_u9898" class="headerlink" title="解决问题"></a>解决问题</h3><p>如果我们监听了form的submit事件，但是又阻止其默认的提交行为，是不是就可以达到效果？<br>在JQuery中有个event.preventDefault()方法，可以阻止元素发生默认的行为和事件。有了这个前提我们就可以实现了。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">form</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--code here--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"submit"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"form"</span>).submit(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u95EE_u9898_u63CF_u8FF0"><a href="#u95EE_u9898_u63CF_u8FF0" class="headerlink" title="问题描述"></a>问题描述</h3><p>html5为我们提供了强大的校验功能，这无疑为我]]>
    </summary>
    
      <category term="html5" scheme="http://blog.coryphaei.com/tags/html5/"/>
    
      <category term="javascript" scheme="http://blog.coryphaei.com/tags/javascript/"/>
    
      <category term="twist.zheng" scheme="http://blog.coryphaei.com/categories/twist-zheng/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java8 lambda表达式]]></title>
    <link href="http://blog.coryphaei.com/2015/12/23/Java8%20lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://blog.coryphaei.com/2015/12/23/Java8 lambda表达式/</id>
    <published>2015-12-23T05:46:00.000Z</published>
    <updated>2016-01-04T13:47:25.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Java8_lambda_u8868_u8FBE_u5F0F"><a href="#Java8_lambda_u8868_u8FBE_u5F0F" class="headerlink" title="Java8 lambda表达式"></a>Java8 lambda表达式</h1><h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>RxJava的逻辑清晰的特点在Java8 lambda表达式下更加突出，学好RxJava必须熟悉lambda表达式。</p>
<h2 id="u672C_u8D28"><a href="#u672C_u8D28" class="headerlink" title="本质"></a>本质</h2><p>lambda表达式的本质是一个匿名方法</p>
<h3 id="u4E3E_u4F8B"><a href="#u4E3E_u4F8B" class="headerlink" title="举例"></a>举例</h3><p>问题：求两个int型数据的和，通常的写法是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>转成lambda以后<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)-&gt;x+y;</span><br></pre></td></tr></table></figure></p>
<p>或者，省略参数类型，java编译器会根据上下文推断<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x,y)-&gt;x+y;</span><br></pre></td></tr></table></figure></p>
<p>或者,可以显示的指明返回值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x,y)-&gt;&#123;<span class="keyword">return</span> x+y;&#125;</span><br></pre></td></tr></table></figure></p>
<p>###小结<br>lambda表达式由三部分组成：参数列表，箭头，表达式/语句块、</p>
<p>无参数的情况<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()-&gt;&#123;Log.i(<span class="string">"TAG"</span>,<span class="string">"Message"</span>);&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果只有一个参数且可以被java推断出类型，那么，参数列表的括号也可以省略：<br>c-&gt;{return c.size;}</p>
<h2 id="u7C7B_u578B"><a href="#u7C7B_u578B" class="headerlink" title="类型"></a>类型</h2><p>lambda表达式的目标类型是“函数接口”，定义是：一个接口，如果只有一个显示声明的抽象方法，那么它就是一个函数接口，最简单的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>特殊情况<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1,T o2)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意接口Comparator，虽然声明了两个方法，貌似与定义不符（只有一个声明的抽象方法），但它的确是一个函数接口，这是因为equals方法是Object的。事实上所有的接口都会声明Object的public方法（大多是隐式的）。</p>
<h2 id="u8D4B_u503C"><a href="#u8D4B_u503C" class="headerlink" title="赋值"></a>赋值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyInterface myInterface = ()-&gt;&#123;Log.i(<span class="string">"Tag"</span>,<span class="string">"Message"</span>);&#125;</span><br></pre></td></tr></table></figure>
<p>然后再赋值给一个Object:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = myInterface;</span><br></pre></td></tr></table></figure></p>
<p>但是不能这样赋值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = ()-&gt;&#123;Log.i(<span class="string">"Tag"</span>,<span class="string">"Message"</span>);&#125;</span><br></pre></td></tr></table></figure></p>
<p>必须显示的转型成为一个函数接口才可以<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = (myInterface)()-&gt;&#123;Log.i(<span class="string">"Tag"</span>,<span class="string">"Message"</span>);&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u4F7F_u7528"><a href="#u4F7F_u7528" class="headerlink" title="使用"></a>使用</h2><h3 id="lambda_u8868_u8FBE_u5F0F_u7528_u5728_u4F55_u5904"><a href="#lambda_u8868_u8FBE_u5F0F_u7528_u5728_u4F55_u5904" class="headerlink" title="lambda表达式用在何处"></a>lambda表达式用在何处</h3><p>举例：未使用Lambda<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread( <span class="keyword">new</span> Runnable () &#123;</span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Log.i(<span class="string">"Tag"</span>,<span class="string">"Message"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>使用lambda<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread&#123;()-&gt;&#123;Log.i(<span class="string">"Tag"</span>,<span class="string">"Message"</span>);&#125;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意第二个线程里的lambda表达式，并不需要将其转成Runnable,因为Java能够根据上下文自动推断，<br>一个Thread的构造函数接受一个Runnable参数，且传入的Lambda表达式正好符合其run()函数，所以java编译器可以推断为Runnable。</p>
<h3 id="u96C6_u5408_u6279_u5904_u7406_u64CD_u4F5C"><a href="#u96C6_u5408_u6279_u5904_u7406_u64CD_u4F5C" class="headerlink" title="集合批处理操作"></a>集合批处理操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Object o:list ) &#123;</span><br><span class="line">  Log.i(<span class="string">"TAG"</span>,o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可转换为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(o-&gt;&#123;Log.i(<span class="string">"TAG"</span>,o)&#125;;)</span><br></pre></td></tr></table></figure></p>
<h3 id="u6D41"><a href="#u6D41" class="headerlink" title="流"></a>流</h3><p>一个流通常以一个集合类实例为其数据源，然后在其上定义各种操作。流的API设计使用了管道模式，对流的一次操作为返回另一个流，从而不同的操作可以串起来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Shape&gt; shapes = ...;</span><br><span class="line">shape.stream()</span><br><span class="line">  .filter(s-&gt;s.getColor() == BLUE)</span><br><span class="line">  .forEach(s-&gt;s.setColor(RED));</span><br></pre></td></tr></table></figure></p>
<p>首先调用stream()方法，以集合类对象shapes里面的元素为数据源，生成一个流，然后在这个流上调用filter方法，跳出蓝色的，返回一个流，最后调用forEach方法将这些蓝色的shape换成红色。<br>另一个例子：一个典型的数据处理方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">distinctPrimary</span><span class="params">(String... numbers)</span> </span>&#123;</span><br><span class="line">       List&lt;String&gt; list = Arrays.asList(numbers);</span><br><span class="line">       List&lt;Integer&gt; r = list.stream()</span><br><span class="line">               .map(e-&gt;&#123;<span class="keyword">new</span> Integer(e)&#125;)</span><br><span class="line">               .filter(e-&gt;Primes.isPrime(e))</span><br><span class="line">               .distinct()</span><br><span class="line">               .collect(Collectors.toList());</span><br><span class="line">       System.out.println(<span class="string">"distinctPrimary result is: "</span> + r);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>1.传入一串String，转成list。用steram()方法生成流<br>2.map方法将每个元素由String转为Integer得到一个新的流。<br>3.filter方法过滤不是素数的数字，并形成一个新的流<br>4.distinct 去重<br>5.collect 将最终结果收集到List中。<br>对于效率问题，前面的map filter distinct都是懒方法，collect是急方法，在遇到急方法之前，懒方法不会执行。<br>当遇到急方法时，前面的懒方法才会开始执行，且是管道式执行。例如对于字符串 “3”,首先将”3”转化为3，在判断他是否是素数，<br>如果是素数，保留3进入distinct方法，如果在队列中已经有3了，则把3丢弃，否则加入到队列中，实际上，”3”只进行了一次遍历操作，<br>而不是像代码中表达的，先把所有字符串转化为数字（第一次循环），再将数字过滤（第二次循环），去重（第三次循环），收集（第四次循环）。</p>
<h3 id="u6536_u96C6_u5668"><a href="#u6536_u96C6_u5668" class="headerlink" title="收集器"></a>收集器</h3><p>上述代码中，collect就是一个收集器，即将所有经过懒方法后被保留下来的数据收集起来。<br>常见的收集器， groupingBy:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给出一个String类型的数组，找出其中各个素数，并统计其出现次数</span></span><br><span class="line">List&lt;String&gt; l = Arrays.asList(String... numbers);</span><br><span class="line">Map&lt;Integer,Integer&gt; r</span><br><span class="line">        = l.stream()</span><br><span class="line">            .map(e-&gt;<span class="keyword">new</span> Integer(e))</span><br><span class="line">            .filter(e-&gt;Prime.isPrime(e))</span><br><span class="line">            .collect(Collectors.groupingBy(p-&gt;p,Collectors.summingInt(p-&gt;<span class="number">1</span>)));</span><br></pre></td></tr></table></figure></p>
<p>相当于将所有收集到的数存放在一个Map中，以元素为Key，出现的次数作为Value。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//给出一个String类型的数组，求其中所有不重复素数的和</span></span><br><span class="line">List&lt;String&gt; l = Arrays.asList(numbers);</span><br><span class="line"><span class="keyword">int</span> sum = l.stream()</span><br><span class="line">            .map(e-&gt;<span class="keyword">new</span> Integer(e))</span><br><span class="line">            .filter(e-&gt;Prime.isPrime(e))</span><br><span class="line">            .distinct()</span><br><span class="line">            .reduce(<span class="number">0</span>,(x,y)-&gt;x+y);</span><br></pre></td></tr></table></figure>
<p>reduce方法用来产生单一的一个最终结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计年龄在25-35岁的男女人数</span></span><br><span class="line"><span class="comment">//List&lt;Person&gt; persons</span></span><br><span class="line">Map&lt;Integer,Integer&gt; result = persons.parallelStream()</span><br><span class="line">                                      .filter(p-&gt;p.getAge&gt;=<span class="number">25</span>&amp;&amp;p.getAge()&lt;=<span class="number">35</span>)</span><br><span class="line">                                      .collect(Collectors.groupingBy(p-&gt;p.getSex(),Collectors.summingInt(p-&gt;<span class="number">1</span>));</span><br></pre></td></tr></table></figure></p>
<h3 id="lambda_u8868_u8FBE_u5F0F_u7684_u66F4_u591A_u7528_u6CD5"><a href="#lambda_u8868_u8FBE_u5F0F_u7684_u66F4_u591A_u7528_u6CD5" class="headerlink" title="lambda表达式的更多用法"></a>lambda表达式的更多用法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//嵌套的lambda表达式</span></span><br><span class="line">Callable&lt;Runnable&gt; c1 = ()-&gt;()-&gt;&#123;System.out.println(<span class="string">"Nested lambda"</span>);&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用在条件表达式中</span></span><br><span class="line">Callable c2 = <span class="keyword">true</span> ? (()-&gt;<span class="number">42</span>);(()-&gt;<span class="number">24</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个递归函数，注意须用this限定</span></span><br><span class="line"><span class="keyword">protected</span> UnaryOperator&lt;Integer&gt; factorial = i -&gt; i == <span class="number">0</span> ? <span class="number">1</span> : i * <span class="keyword">this</span>.factorial.apply( i - <span class="number">1</span> );</span><br></pre></td></tr></table></figure>
<h3 id="u65B9_u6CD5_u5F15_u7528"><a href="#u65B9_u6CD5_u5F15_u7528" class="headerlink" title="方法引用"></a>方法引用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer::parseInt<span class="comment">//静态方法引用</span></span><br><span class="line">System.out::print<span class="comment">//实例方法引用</span></span><br><span class="line">Person::<span class="keyword">new</span><span class="comment">//构造器引用</span></span><br></pre></td></tr></table></figure>
<p>举例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c1 与 c2 是一样的（静态方法引用）</span></span><br><span class="line">Comparator&lt;Integer&gt; c2 = (x, y) -&gt; Integer.compare(x, y);</span><br><span class="line">Comparator&lt;Integer&gt; c1 = Integer::compare;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面两句是一样的（实例方法引用1）</span></span><br><span class="line">persons.forEach(e -&gt; System.out.println(e));</span><br><span class="line">persons.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面两句是一样的（实例方法引用2）</span></span><br><span class="line">persons.forEach(person -&gt; person.eat());</span><br><span class="line">persons.forEach(Person::eat);</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面两句是一样的（构造器引用）</span></span><br><span class="line">strList.stream().map(s -&gt; <span class="keyword">new</span> Integer(s));</span><br><span class="line">strList.stream().map(Integer::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="u751F_u6210_u5668_u51FD_u6570"><a href="#u751F_u6210_u5668_u51FD_u6570" class="headerlink" title="生成器函数"></a>生成器函数</h3><p>生成器函数会产生一系列元素，供给一个流。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.generate(Supplier&lt;T&gt; s)</span><br></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.generate(Math::random)</span><br><span class="line">      .limit(<span class="number">5</span>)</span><br><span class="line">      .forEach(System.out::println);</span><br></pre></td></tr></table></figure></p>
<p>limit(5)，如果没有这个调用，那么这条语句会永远地执行下去。也就是说这个生成器是无穷的。这种调用叫做终结操作，或者短路操作。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Java8_lambda_u8868_u8FBE_u5F0F"><a href="#Java8_lambda_u8868_u8FBE_u5F0F" class="headerlink" title="Java8 lambda表达式"></a>Java8 lambd]]>
    </summary>
    
      <category term="Android" scheme="http://blog.coryphaei.com/tags/Android/"/>
    
      <category term="Java" scheme="http://blog.coryphaei.com/tags/Java/"/>
    
      <category term="Java8" scheme="http://blog.coryphaei.com/tags/Java8/"/>
    
      <category term="Lambda" scheme="http://blog.coryphaei.com/tags/Lambda/"/>
    
      <category term="Basti" scheme="http://blog.coryphaei.com/categories/Basti/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[javascript之promise初识]]></title>
    <link href="http://blog.coryphaei.com/2015/12/16/javascript%E4%B9%8Bpromise%E5%88%9D%E8%AF%86/"/>
    <id>http://blog.coryphaei.com/2015/12/16/javascript之promise初识/</id>
    <published>2015-12-16T09:30:34.000Z</published>
    <updated>2016-01-04T13:47:25.000Z</updated>
    <content type="html"><![CDATA[<h3 id="promise_u662F_u4EC0_u4E48_uFF1F"><a href="#promise_u662F_u4EC0_u4E48_uFF1F" class="headerlink" title="promise是什么？"></a>promise是什么？</h3><p>在javascript promise机制出现之前，基于javascript的异步回调机制，当我们要顺序执行一段代码时，需要在异步回调里面执行代码，有时候需要在回调里面添加回调函数，如此一来，以前写代码之前代码是这样的：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">firstAsrc(<span class="function"><span class="keyword">function</span><span class="params">(item)</span></span>&#123;          <span class="comment">//第一个异步回调函数</span></span><br><span class="line">    <span class="comment">//coding do something</span></span><br><span class="line">    secondASrc(<span class="function"><span class="keyword">function</span><span class="params">(item)</span></span>&#123;    <span class="comment">//第二个回掉函数</span></span><br><span class="line">        <span class="comment">//coding do something</span></span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p>
<p>这还是只有两个回调函数，如果有十几个呢，我相信你就会疯了，至少我会。<br>所以，promise是用来解决javascript中层层异步调用，实现链式调用模式的一种机制。</p>
<h3 id="promise_u7684_u7528_u6CD5"><a href="#promise_u7684_u7528_u6CD5" class="headerlink" title="promise的用法"></a>promise的用法</h3><p>promise在es6中已经得到了完美支持，而nodejs中也有promise的三方类库支持。现在我们来看看promise到底要怎么使用。</p>
<p>现在我们使用promise来实现函数的顺序调用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设以下函数中都包含异步调用逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">firstAsrc</span>(<span class="params">resolve,reject</span>)</span>&#123;   <span class="comment">//接受两个函数作为参数，处理正常事务和异常的事务</span></span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"step 1"</span>);</span><br><span class="line">   <span class="keyword">if</span>(a==<span class="number">1</span>)&#123;</span><br><span class="line">      resolve(data);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     reject(data);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">secondAsrc</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"step 2"</span>);</span><br><span class="line">  <span class="keyword">if</span>(a==<span class="number">1</span>)&#123;</span><br><span class="line">     resolve(data);          <span class="comment">//交给下一个promise的resolve函数</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    reject(data);           <span class="comment">//交给下一个promise的reject函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thirdAsrc</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"step 3"</span>);</span><br><span class="line">  <span class="keyword">if</span>(a==<span class="number">1</span>)&#123;</span><br><span class="line">     resolve(data);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    reject(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(firstAsrc).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"firstAsrc success"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(secondAsrc);</span><br><span class="line">  &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"firstAsrc error"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(secondAsrc);</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"secondASrc success"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(thirdAsrc);</span><br><span class="line">  &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"secondASrc error"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(thirdAsrc);</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"thirdAsrc success"</span>);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"thirdAsrc error"</span>);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<p>打印顺序:<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">step</span> <span class="number">1</span></span><br><span class="line">firstAsrc success</span><br><span class="line"><span class="keyword">step</span> <span class="number">2</span></span><br><span class="line">secondASrc success</span><br><span class="line"><span class="keyword">step</span> <span class="number">3</span></span><br><span class="line">thirdAsrc success</span><br></pre></td></tr></table></figure></p>
<p>现在我们来看看上面的代码,<code>Promise</code> 类是一个对象，这个对象有一个<code>then</code>方法，then方法有两个参数，这两个参数传入两个函数resolve和reject,所有的回调只执行者两个函数中的任意一个，其中resolve用于处理成功的回调，reject用户处理异常的回调。一般的形式为<code>promise.then(resolve,reject)</code>。</p>
<p>我们注意到then函数执行完后返回的还是一个Promise对象<code>return new Promise(secondAsrc)</code>,Promise对象的构造函数接收一个带有异步逻辑的函数（这个函数在<code>new Promise(func)</code>时执行)作为参数。既然then方法里面返回的依然是promise对象，那么是否意味着我们可以继续调用then方法呢？如上，确实如此。这样我们就可以将异步调用以链式的形式实现.</p>
<p>Promise的主要用法就是将各个异步操作封装成好多Promise，而一个Promise只处理一个异步逻辑。最后将各个Promise用链式调用写法串联，在这样处理下，如果异步逻辑之间前后关系很重的话，你也不需要层层嵌套，只需要把每个异步逻辑封装成Promise链式调用就可以了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="promise_u662F_u4EC0_u4E48_uFF1F"><a href="#promise_u662F_u4EC0_u4E48_uFF1F" class="headerlink" title="promise是什么？"></a>promise是什么？</]]>
    </summary>
    
      <category term="javascript" scheme="http://blog.coryphaei.com/tags/javascript/"/>
    
      <category term="nodejs" scheme="http://blog.coryphaei.com/tags/nodejs/"/>
    
      <category term="twist.zheng" scheme="http://blog.coryphaei.com/categories/twist-zheng/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Objective-C新纪元--ReactiveCocoa框架]]></title>
    <link href="http://blog.coryphaei.com/2015/12/15/Objective-C%E6%96%B0%E7%BA%AA%E5%85%83--ReactiveCocoa%E6%A1%86%E6%9E%B6/"/>
    <id>http://blog.coryphaei.com/2015/12/15/Objective-C新纪元--ReactiveCocoa框架/</id>
    <published>2015-12-15T06:56:46.000Z</published>
    <updated>2016-01-04T13:47:25.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>很久之前我就准备写有关于ReactiveCocoa的文章，前面林林总总写过几篇，但是都是简单的讲述，并没有深刻的去总结这个技术。根本的原因在于这个技术确实很难入门，但是ReactiveCocoa的出现确实可以给iOS带来很多新的思考和实现，ReactiveCocoa更加被Mattt Thompson大神称为开启一个新Objective-C纪元。另外提醒大家，我看到的优秀的讲ReactiveCocoa的文章篇幅都很长，其实大家都在简洁的语言来讲，我的这边文章应该写完也是长篇幅，希望大家可以耐心的看完。</p>
<h1 id="u51FD_u6570_u54CD_u5E94_u5F0F_u7F16_u7A0B"><a href="#u51FD_u6570_u54CD_u5E94_u5F0F_u7F16_u7A0B" class="headerlink" title="函数响应式编程"></a>函数响应式编程</h1><p>ReactiveCocoa的基本思想就是<code>函数响应式编程（Function Reactive Programming，以下简称FRP）</code>。FRP是一种响应变化的编程范式。我们通常会拿一个经典的例子来解释概念。</p>
<h2 id="u7406_u5FF5"><a href="#u7406_u5FF5" class="headerlink" title="理念"></a>理念</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = a + b<span class="comment">// c = 4</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">4</span></span><br><span class="line"><span class="comment">// 现在c的值是多少？</span></span><br></pre></td></tr></table></figure>
<p>上面的问题，正常人一眼就能看出答案，因为我们<code>响应</code>了<code>b = 2</code>这个值的变化，所以说<code>c</code>的值会随着<code>b</code>的值的改变而改变。FRP就是使用这样的基本原理，所以称之为<code>响应式编程</code>。</p>
<h2 id="u5982_u4F55_u5B9E_u73B0"><a href="#u5982_u4F55_u5B9E_u73B0" class="headerlink" title="如何实现"></a>如何实现</h2><p>FRP提供了<code>信号（Signal）</code>机制来实现这样的效果，通过信号来记录值的变化。通过信号的组合，从而不再去监听值的变化，甚至是事件的变化。在上述例子中加入了signal的图解：<br><img src="http://7xp57v.com1.z0.glb.clouddn.com/coryphaei/FRP_signal.png" alt="FRP_signal"></p>
<h2 id="ReactiveCocoa_u4F5C_u8005_u5BF9_u4E8EFRP_u7684_u89E3_u91CA"><a href="#ReactiveCocoa_u4F5C_u8005_u5BF9_u4E8EFRP_u7684_u89E3_u91CA" class="headerlink" title="ReactiveCocoa作者对于FRP的解释"></a>ReactiveCocoa作者对于FRP的解释</h2><p><a href="http://blog.maybeapps.com/post/42894317939/input-and-output" target="_blank" rel="external">Josh Abernathy这样解释它：</a></p>
<blockquote>
<p>程序接收输入产生输出。输出就是对输入做了一些事的结果。输入，转换，输出，完成。<br>输入是应用动作的全部来源。点击、键盘事件、定时器事件、GPS时间、网络请求响应都算是输入。这些事件被传递到应用中，应用将他们以某种方式混合，产生了结果：就是输出。<br>输出通常会改变应用的UI。开关状态变化、列表有了新的元素都是UI变化。也有可能让磁盘上某个文件产生变化，或者产生一个API请求，这都是应用的输出。<br>但不像传统的输入输出设计，应用的输入输出可以产生很多次。应用打开后，不只是一个简单的 输入→工作→输出 就构成了一个生命周期。应用经常有大量的输入并基于这些输入产生输出。</p>
</blockquote>
<h2 id="u8BDD_u5916"><a href="#u8BDD_u5916" class="headerlink" title="话外"></a>话外</h2><p>关于ReactiveCocoa的灵感来源，我们可以看到官方README中提到了<code>ReactiveCocoa深受Microsoft&#39;s Reactive Extension的思想，并基于Reactive Extension（Rx）</code>。但是官方列举了很多ReactiveCocoa有别于Rx的地方，有兴趣的可以去了解下。</p>
<h1 id="ReactiveCocoa"><a href="#ReactiveCocoa" class="headerlink" title="ReactiveCocoa"></a>ReactiveCocoa</h1><p><a href="http://reactivecocoa.io/" target="_blank" rel="external">ReactiveCocoa</a> is a framework developed by <a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">GitHub</a> to support functional reactive programming on iOS and OS X.</p>
<h2 id="u8D77_u56E0"><a href="#u8D77_u56E0" class="headerlink" title="起因"></a>起因</h2><p>作为一个移动开发者，应用中经常有大量的输入，大部分的代码都用来响应这些输出并且基于这些输入来产生输出。我们需要响应的事件非常多：按钮点击事件（target-action）、网络消息回调事件（Block or delegate）、属性变化事件（KVO）、通知事件（NSNotification）等，而这边响应事件在代码中的表现形式却并不统一。为了定义一个标准统一的事件处理接口，并且通过定义的接口来进行组合使用，ReactiveCocoa出现了。</p>
<h2 id="u57FA_u672C_u601D_u60F3"><a href="#u57FA_u672C_u601D_u60F3" class="headerlink" title="基本思想"></a>基本思想</h2><p>我们GitHub主页上看到，官方这样给出了概念：</p>
<blockquote>
<p>ReactiveCocoa (RAC)是采用FRP的一个Cocoa framework。RAC提供了API用来组合、转换一直变化的数据流。</p>
</blockquote>
<p>ReactiveCocoa采用FRP思想，<code>信号</code>则是这个思想的精髓所在，灵魂所在。在ReactiveCocoa简称是RAC，所有的类都以<code>RAC</code>开头，所以说ReactiveCocoa中的信号就用<code>RACSignal</code>类来表示，用来展示<code>事件流</code>的变化，并且可以通过链接、过滤、组合等方式来进行处理。</p>
<blockquote>
<p>引用我在很多博客中看到的一段话，但是我对其做了改动，加入了桶的概念：<br>可以把信号(signal)想象成水龙头，只不过里面不是水，而是玻璃球(stream of value)，直径跟水管的内径一样，这样就能保证玻璃球是依次排列，不会出现并排的情况(数据都是线性处理的，不会出现并发情况)。只要你打开水龙头的开关，就会有玻璃球出来。但是，并不是所有的玻璃球都能被使用，除非有了桶(subscriber)来接收掉下来的玻璃球，这样才能运往需要的地方。这样有新的玻璃球进来，有桶在监听，就会自动传送给接收者。可以在水龙头上加一个过滤嘴(filter)，不符合的不让通过，也可以加一个改动装置，把球改变成符合自己的需求(map)。也可以把多个水龙头合并成一个新的水龙头(combineLatest:reduce:)，这样只要其中的一个水龙头有玻璃球出来，这个新合并的水龙头就会得到这个球。</p>
</blockquote>
<h2 id="u601D_u8003"><a href="#u601D_u8003" class="headerlink" title="思考"></a>思考</h2><p>通过上述对其的了解，总结ReactiveCocoa带来的影响。</p>
<ul>
<li>定义标准的事件处理接口</li>
<li>解决了状态过多依赖的问题</li>
</ul>
<p>PS：关于巧哥说的给Controller瘦身的问题，我认为这个是MVVM框架所带来的影响，ReactiveCocoa只是很好的配合了MVVM。因此我并没有把这一点归纳在内。</p>
<h1 id="u5F00_u59CB"><a href="#u5F00_u59CB" class="headerlink" title="开始"></a>开始</h1><p>进入正轨，开始介绍ReactiveCocoa的机制和常用方法。</p>
<h2 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h2><p>推荐大家用<a href="http://code4app.com/article/cocoapods-install-usage" target="_blank" rel="external">CocoaPods</a>进行安装，这么好的工具肯定要掌握的。<br><img src="http://7xp57v.com1.z0.glb.clouddn.com/coryphaei/cocoapods.png" alt="CocoaPods"><br>目前4.0的alpha版本正在开发，建议大家先使用发布的版本。如果你用swift来写可以用3.0，我是用的Objective，所以用的2.5版本，Podfile:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">platform <span class="symbol">:ios</span>, <span class="string">'8.0'</span></span><br><span class="line">pod <span class="string">'ReactiveCocoa'</span>, <span class="string">'~&gt; 2.5'</span></span><br></pre></td></tr></table></figure></p>
<h2 id="RACStreams"><a href="#RACStreams" class="headerlink" title="RACStreams"></a>RACStreams</h2><p><code>RACStreams</code>官方定义<code>An abstract class representing any stream of values</code>，我翻译下RACStreams是展现任何数据流的一个抽象类。RACStreams通俗点讲就是上面那段话中<code>水管里面线性流动的、具有顺序的玻璃球</code>。RACStreams因为是一个抽象类，我们使用中很少直接接触到，我们一般是使用继承自RACStreams的<code>RACSignal</code>和<code>RACSequence</code>。对于RACSignal和RACSequence与RACStreams联系，我觉得可以直接用<a href="http://nshipster.cn/reactivecocoa/" target="_blank" rel="external">NShipster</a>中一句话：</p>
<blockquote>
<p>signal是push驱动的stream，sequence是pull驱动的stream。</p>
</blockquote>
<h2 id="RACSignal_and_RACSubscriber"><a href="#RACSignal_and_RACSubscriber" class="headerlink" title="RACSignal and RACSubscriber"></a>RACSignal and RACSubscriber</h2><p><code>RACSignal</code>是ReactiveCocoa的核心所在，有了它就能开始使用ReactiveCocoa。RACSignal通俗点讲就是上面那段话中所提到的<code>水龙头</code>，表示未来要到到达的值。比较类似于一个概念，叫做<code>future and promise</code>，大家可以自行去了解下。<br><code>RACSubscriber</code>是订阅者，通俗点说就是上面那段话中用来装玻璃球的<code>桶</code>。我们可以用一个更好的比喻来理解一下。把RACSignal比作插头，把RACSubscriber比作插座，插头负责去用电，插座负责去取点，插头插座配套才能使用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span><span class="variable">.usernameTextField</span><span class="variable">.rac_textSignal</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="u51B7_u4FE1_u53F7_28Cold_29_u548C_u70ED_u4FE1_u53F7_28Hot_29"><a href="#u51B7_u4FE1_u53F7_28Cold_29_u548C_u70ED_u4FE1_u53F7_28Hot_29" class="headerlink" title="冷信号(Cold)和热信号(Hot)"></a>冷信号(Cold)和热信号(Hot)</h3><p>在上文中提到的插头插座比喻中，如果说只有插头，没有插座，即只有RACSignal，而没有RACSubscriber，则把RACSignal称之为冷信号，而冷信号默认是不进行任何操作的。只要加上RACSubscriber，就可以进行操作，这个时候RACSignal就被称作是热信号。如果说只有插座，没有插头，那么只要去找到插头就能解决问题。</p>
<h3 id="RACReplaySubject"><a href="#RACReplaySubject" class="headerlink" title="RACReplaySubject"></a>RACReplaySubject</h3><p>我们继续上文中的插头插座比喻，如果现在同时有多个插座在等待一个插头用电，那么我就要把这个插头多次拔下来插到所有的插座上。大家都不愿意重复这个操作，ReactiveCocoa提供了<code>RACReplaySubject</code>方法，保证<code>RACSignal</code>只触发一次。把需要send的value存起来，直接发送缓存数据。</p>
<h3 id="u8BE6_u89E3"><a href="#u8BE6_u89E3" class="headerlink" title="详解"></a>详解</h3><p>RACSignal一共会发送三种事件给RACSubscriber，RACSubscriber通过-subscribeNext:error:completed:对不同事件作出相应反应</p>
<ul>
<li>next 继续进行发送</li>
<li>error 出现错误  </li>
<li>completed 完成</li>
</ul>
<p>一个RACSignal会因为error和completed的出现而终止，即生命周期中只会有一个errot或者completed，但是却可以多次发送next事件。而我们接下来要讨论的就是如何来处理这些多次next事件。</p>
<h2 id="RACSequence"><a href="#RACSequence" class="headerlink" title="RACSequence"></a>RACSequence</h2><p><code>RACSequence</code>官方的解释是一组immutable且有序的values，很多人说把这个看做是<code>NSArray</code>。但是注意用词是<code>看做</code>，因为这些values的值是<code>懒加载</code>(只有需要的时候才加载)，这样sequence只有一部分被用到，会一定程度得提升性能。那么NSArray可以通过rac_sequence方法转换成RACSequence来调用RAC中的方法了。像Cocoa的集合类型一样，RACSequence不接受<code>nil</code>。</p>
<h2 id="map__u2013__u4FEE_u6539"><a href="#map__u2013__u4FEE_u6539" class="headerlink" title="map – 修改"></a>map – 修改</h2><p><code>map</code> calls its block with each user that’s fetched and returns a new. 解释一下就是将事件中获得的数据映射为你想要的对象，可以看做对玻璃球的重新包装。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[[<span class="keyword">self</span><span class="variable">.usernameTextField</span><span class="variable">.rac_textSignal</span> map:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *text) &#123;</span><br><span class="line">    <span class="keyword">return</span> @(text<span class="variable">.length</span>);</span><br><span class="line"> &#125;]</span><br><span class="line"> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure></p>
<h2 id="filter__u2013__u8FC7_u6EE4"><a href="#filter__u2013__u8FC7_u6EE4" class="headerlink" title="filter – 过滤"></a>filter – 过滤</h2><p><code>Filters</code> out values in the receiver that don’t pass the given test. 非常简单对事件中的内容进行过滤，可以看做不合要求的玻璃球进行拦击，不允许通过水管。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[[<span class="keyword">self</span><span class="variable">.usernameTextField</span><span class="variable">.rac_textSignal</span> map:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *text) &#123;</span><br><span class="line">    <span class="keyword">return</span> @(text<span class="variable">.length</span>);</span><br><span class="line"> &#125;]</span><br><span class="line"> filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSNumber</span> *length) &#123;</span><br><span class="line">     <span class="keyword">return</span> [length intValue] &gt; <span class="number">3</span>;</span><br><span class="line"> &#125;]</span><br><span class="line"> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure></p>
<h2 id="combineLatest__u2013__u7EC4_u5408"><a href="#combineLatest__u2013__u7EC4_u5408" class="headerlink" title="combineLatest – 组合"></a>combineLatest – 组合</h2><p><code>Combines</code> the latest values from the receiver and the given signal into RACTuples, once both have sent at least one next. 将一组事件组合为一个输出最新事件的signal。可以看做是对水管进行改造，使得任何时刻都输出最新的玻璃球。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signUpActiveSignal = [RACSignal combineLatest:@[validUsernameSignal, validPasswordSignal]</span><br><span class="line">                                                  reduce:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *usernameValid, <span class="built_in">NSNumber</span> *passwordValid)&#123;</span><br><span class="line">                                                      <span class="keyword">return</span> @([usernameValid boolValue] &amp;&amp; [passwordValid boolValue]);</span><br><span class="line">                                                  &#125;];</span><br></pre></td></tr></table></figure></p>
<h2 id="flatten__u2013__u5408_u5E76"><a href="#flatten__u2013__u5408_u5E76" class="headerlink" title="flatten – 合并"></a>flatten – 合并</h2><p><code>flatten</code>把事件进行合并，对于其中的内容都进行显示，来一个显示一个，可以交叉显示。可以看做把多个水管进行了合并，哪个水管中的玻璃球到了就放出玻璃球。</p>
<h2 id="flattenMap__u2013__u89E3_u51B3signal_of_signals"><a href="#flattenMap__u2013__u89E3_u51B3signal_of_signals" class="headerlink" title="flattenMap – 解决signal of signals"></a>flattenMap – 解决signal of signals</h2><p>Maps <code>block</code> across the values in the receiver and flattens the result.<br>这个问题首先要先解释一下。就是说事件完成block后有可能会返回signal的实例，这个时候外部信号中就会包含一个内部信号，这个时候使用map去讲信号转换为另一种信号，造成了嵌套的麻烦。所以说通过flattenMap将事件从内部信号发送到外部信号，并且映射到另外一个信号上去，这样这个过程就变得扁平化。Signal被按序的链接起来执行异步操作，而且不用嵌套block。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)signInSignal</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.signInService</span> signInWithUsername:<span class="keyword">self</span><span class="variable">.usernameTextField</span><span class="variable">.text</span></span><br><span class="line">                                      password:<span class="keyword">self</span><span class="variable">.passwordTextField</span><span class="variable">.text</span></span><br><span class="line">                                      complete:^(<span class="built_in">BOOL</span> success) &#123;</span><br><span class="line">                                          [subscriber sendNext:@(success)];</span><br><span class="line">                                          [subscriber sendCompleted];</span><br><span class="line">                                      &#125;];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[[[<span class="keyword">self</span><span class="variable">.signInButton</span> rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>] flattenMap:^RACStream *(<span class="keyword">id</span> value) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> signInSignal];</span><br><span class="line">&#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Sign in result: %@"</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<h2 id="u5FAA_u73AF_u5F15_u7528"><a href="#u5FAA_u73AF_u5F15_u7528" class="headerlink" title="循环引用"></a>循环引用</h2><p>ReactiveCocoa使用时大量的使用了block，而由于Ojective-C语言的内存管理机制使用的引用计数，会造成循环引用的问题。为了避免循环引用的问题，通常的解决办法是声明其中的一个变量为弱引用weak，将其赋值给self，在block中来使用这个弱引用的self，为了简单，通常使用了一个语法糖：<code>@weakify(self)</code>和<code>@strongify(self)</code>。</p>
<h2 id="u5E38_u7528_u5B8F_u5B9A_u4E49"><a href="#u5E38_u7528_u5B8F_u5B9A_u4E49" class="headerlink" title="常用宏定义"></a>常用宏定义</h2><ul>
<li><p>RAC()可以将信号的某个属性与其他的信号进行联动。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RAC(<span class="keyword">self</span><span class="variable">.submitButton</span><span class="variable">.enabled</span>) = [RACSignal combineLatest:@[<span class="keyword">self</span><span class="variable">.usernameField</span><span class="variable">.rac_textSignal</span>, <span class="keyword">self</span><span class="variable">.passwordField</span><span class="variable">.rac_textSignal</span>] reduce:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *userName, <span class="built_in">NSString</span> *password) &#123;</span><br><span class="line">    <span class="keyword">return</span> @(userName<span class="variable">.length</span> &gt;= <span class="number">6</span> &amp;&amp; password<span class="variable">.length</span> &gt;= <span class="number">6</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
</li>
<li><p>RACObserve()监听信号的属性的改变，使用block的KVO</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[RACObserve(<span class="keyword">self</span><span class="variable">.textField</span>, text) subscribeNext:^(<span class="built_in">NSString</span> *newName) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, newName);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><p><img src="http://7xp57v.com1.z0.glb.clouddn.com/coryphaei/mvvm.png" alt="MVVM"></p>
<h2 id="u4E3A_u4EC0_u4E48_u8981_u63D0_u5230MVVM"><a href="#u4E3A_u4EC0_u4E48_u8981_u63D0_u5230MVVM" class="headerlink" title="为什么要提到MVVM"></a>为什么要提到MVVM</h2><p>MVVM其实是MVC的变形框架，主要来解决目前iOS应用中日益增长的重量级Controller的问题。在你使用ReactiveCocoa的时候会发现将事件定义统一接口后确实方便了代码的编写，但是都在Controller中来进行使得Conttroller异常的臃肿。这个也就是为什么很多人写到ReactiveCocoa的时候一定会提到MVVM的原因，建议大家配合使用，将ReactiveCocoa处理事件的代码写在ViewModel中，这样也方便做测试，昨天听了LeanCloud智维大神的自动化和测试之后，也准备来探究一下，应该到时候会出一篇博客。</p>
<h2 id="u5173_u4E8EMVVM"><a href="#u5173_u4E8EMVVM" class="headerlink" title="关于MVVM"></a>关于MVVM</h2><p>关于MVVM，这里不做详细的讲解，不是本章的重点。但是可以给出几篇参考，有兴趣的同学可以去了解一下。</p>
<ul>
<li><a href="http://objccn.io/issue-13-1/" target="_blank" rel="external">MVVM 介绍</a></li>
<li><a href="http://www.infoq.com/cn/articles/rethinking-mvc-mvvm" target="_blank" rel="external">被误解的MVC和被神化的MVVM
</a></li>
</ul>
<h1 id="u6700_u540E"><a href="#u6700_u540E" class="headerlink" title="最后"></a>最后</h1><p>我尽管认真的学习了一周ReactiveCocoa，但是仍然还处在入门阶段，也许等我实战之后会有更多的体会和坑来告诉大家，但是这个是重框架，入门还是比较难的，我尽我所能的理解写下这个博客，希望能帮助大家入个门，同时我也给出几篇参考文章，希望对大家有帮助。</p>
<ul>
<li><a href="http://nshipster.cn/reactivecocoa/" target="_blank" rel="external">Reactive​Cocoa</a></li>
<li><a href="http://limboy.me/ios/2013/12/27/reactivecocoa-2.html" target="_blank" rel="external">说说ReactiveCocoa 2</a></li>
<li><a href="http://yulingtianxia.com/blog/2014/07/29/reactivecocoa/" target="_blank" rel="external">ReactiveCocoa学习笔记</a></li>
<li><a href="http://southpeak.github.io/blog/2014/08/02/reactivecocoazhi-nan-%5B%3F%5D-:xin-hao/" target="_blank" rel="external">ReactiveCocoa Tutorial – the Definitive Introduction: Part 1/2</a></li>
<li><a href="http://www.itiger.me/?p=38" target="_blank" rel="external">使用ReactiveCocoa实现iOS平台响应式编程</a></li>
<li><a href="http://blog.devtang.com/blog/2014/02/11/reactivecocoa-introduction/" target="_blank" rel="external">唐巧 ReactiveCocoa - iOS开发的新框架</a></li>
</ul>
<h1 id="u89C6_u9891"><a href="#u89C6_u9891" class="headerlink" title="视频"></a>视频</h1><iframe height="498" width="510" src="http://player.youku.com/embed/XMTQxOTIyOTQyMA==" frameborder="0" allowfullscreen></iframe>

<h1 id="update"><a href="#update" class="headerlink" title="update"></a>update</h1><ul>
<li>2015.12.22 上周六的时候，<a href="https://github.com/DeveloperLx" target="_blank" rel="external">DeveloperLx</a>讲了有关于ReactiveCocoa的很多干货，我写了一篇<a href="">博客</a>，大部分都是对他将的内容的整理和一点感悟。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>很久之前我就准备写有关于ReactiveCocoa的文章，前面林林总总写过几篇，但是都是简单的讲述，并没]]>
    </summary>
    
      <category term="Objective-C" scheme="http://blog.coryphaei.com/tags/Objective-C/"/>
    
      <category term="ReactiveCocoa" scheme="http://blog.coryphaei.com/tags/ReactiveCocoa/"/>
    
      <category term="iOS" scheme="http://blog.coryphaei.com/tags/iOS/"/>
    
      <category term="叶帆" scheme="http://blog.coryphaei.com/categories/%E5%8F%B6%E5%B8%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RxJava学习笔记——使用场景]]></title>
    <link href="http://blog.coryphaei.com/2015/12/15/RxJava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%94)/"/>
    <id>http://blog.coryphaei.com/2015/12/15/RxJava学习笔记(五)/</id>
    <published>2015-12-15T05:42:20.000Z</published>
    <updated>2016-01-04T13:47:25.000Z</updated>
    <content type="html"><![CDATA[<h1 id="RxJava_u7B14_u8BB05"><a href="#RxJava_u7B14_u8BB05" class="headerlink" title="RxJava笔记5"></a>RxJava笔记5</h1><h2 id="u573A_u666F_u4E3E_u4F8B"><a href="#u573A_u666F_u4E3E_u4F8B" class="headerlink" title="场景举例"></a>场景举例</h2><h3 id="u573A_u666F1"><a href="#u573A_u666F1" class="headerlink" title="场景1"></a>场景1</h3><h4 id="u9700_u6C42_uFF1A"><a href="#u9700_u6C42_uFF1A" class="headerlink" title="需求："></a>需求：</h4><p>1.有一字符串，每个字符都是一个数字</p>
<p>2.将字符串转化为数字</p>
<p>3.过滤掉小于1的元素</p>
<p>4.去重</p>
<p>5.取前三个元素</p>
<p>6.求和</p>
<h4 id="u4EE3_u7801"><a href="#u4EE3_u7801" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Subscriber&lt;Integer&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.i(<span class="string">"TAG"</span>,<span class="string">"onCompleted"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                Log.i(<span class="string">"TAG"</span>,<span class="string">""</span>+integer);<span class="comment">//最后输出为9</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Observable.just(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>)</span><br><span class="line">                .map(<span class="keyword">new</span> Func1&lt;String, Integer&gt;() &#123;</span><br><span class="line">                    <span class="annotation">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> Integer.parseInt(s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)<span class="comment">//map操作符将String转化为integer</span></span><br><span class="line">                .filter(<span class="keyword">new</span> Func1&lt;Integer, Boolean&gt;() &#123;</span><br><span class="line">                    <span class="annotation">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> integer&gt;<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)<span class="comment">//filter操作符过滤&lt;=1的数字</span></span><br><span class="line">                .distinct()<span class="comment">//去重</span></span><br><span class="line">                .take(<span class="number">3</span>)<span class="comment">//前三个</span></span><br><span class="line">                .reduce(<span class="keyword">new</span> Func2&lt;Integer, Integer, Integer&gt;() &#123;</span><br><span class="line">                    <span class="annotation">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">(Integer integer, Integer integer2)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> integer+integer2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)<span class="comment">//reduce操作符 求和</span></span><br><span class="line">                .subscribe(subscriber);</span><br></pre></td></tr></table></figure>
<p>因为我Android Studio打死也没装上lamda表达式插件，导致不能用Java8新特性，否则代码为更加整齐简介，这个是大头鬼给出的Java8写法，纯手打，没有经过测验<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>)</span><br><span class="line">        .map(Integer::parseInt)<span class="comment">//map操作符将String转化为integer</span></span><br><span class="line">        .filter(s -&gt; s&gt;<span class="number">1</span>)<span class="comment">//filter操作符过滤&lt;=1的数字</span></span><br><span class="line">        .distinct()<span class="comment">//去重</span></span><br><span class="line">        .take(<span class="number">3</span>)<span class="comment">//前三个</span></span><br><span class="line">        .reduce((integer,integer2) -&gt;integer.intValue()+integer2.intValue())<span class="comment">//reduce操作符 求和</span></span><br><span class="line">        .subscribe(subscriber);</span><br></pre></td></tr></table></figure></p>
<p>再想想如果不用RxJava，各种嵌套if else，说实话这是我第一次体会到RxJava的好处。另外Java8也是神器，原本Java繁琐的语法一下变得简单，下一步就是要去学习Java8新特性了。</p>
<h2 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h2><p>到这总算有了一个还不错的使用场景（还不错是指接近实际生产环境，且能够体现出RxJava优势的使用场景），应该来说对RxJava能有个比较清晰的认识了。另外根据大头鬼的总结，RxJava的使用场景为：<br>1.出现多层嵌套回调</p>
<p>2.复杂的数据处理</p>
<p>3.响应式UI</p>
<p>4.复杂的线程切换</p>
<h2 id="u89C6_u9891_u5730_u5740"><a href="#u89C6_u9891_u5730_u5740" class="headerlink" title="视频地址"></a>视频地址</h2><p><a href="http://boolan.com/lecture/1000001243#0-tsina-1-68759-397232819ff9a47a7b7e80a40613cfe1" target="_blank" rel="external">大头鬼的RxJava视频</a></p>
<h2 id="u8865_u5145_u4E4B_u524D_u7684_u4E00_u70B9"><a href="#u8865_u5145_u4E4B_u524D_u7684_u4E00_u70B9" class="headerlink" title="补充之前的一点"></a>补充之前的一点</h2><p>当调用Obeservable.subscibe(subscriber)时，会返回一个Subscription对象，这个对象代表了被观察者和订阅者的关系<br>Subscription subscription = Obeservable.just(“Hello”)<br>  .subscibe(s -&gt; system.out.println(s));</p>
<p>可以在Activity的onPause()中使用 subscription.unsubscribe();停止被观察者和订阅者的关系以防止内存泄露的问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="RxJava_u7B14_u8BB05"><a href="#RxJava_u7B14_u8BB05" class="headerlink" title="RxJava笔记5"></a>RxJava笔记5</h1><h2 id="u573A_u666F_u4E3E]]>
    </summary>
    
      <category term="Android" scheme="http://blog.coryphaei.com/tags/Android/"/>
    
      <category term="RxJava" scheme="http://blog.coryphaei.com/tags/RxJava/"/>
    
      <category term="Basti" scheme="http://blog.coryphaei.com/categories/Basti/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RxJava学习笔记——操作符与线程切换]]></title>
    <link href="http://blog.coryphaei.com/2015/12/15/RxJava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)/"/>
    <id>http://blog.coryphaei.com/2015/12/15/RxJava学习笔记(三)/</id>
    <published>2015-12-15T05:40:20.000Z</published>
    <updated>2016-01-04T13:47:25.000Z</updated>
    <content type="html"><![CDATA[<h1 id="RxJava_u7B14_u8BB03"><a href="#RxJava_u7B14_u8BB03" class="headerlink" title="RxJava笔记3"></a>RxJava笔记3</h1><h2 id="u53D8_u6362"><a href="#u53D8_u6362" class="headerlink" title="变换"></a>变换</h2><h3 id="u6982_u5FF5"><a href="#u6982_u5FF5" class="headerlink" title="概念"></a>概念</h3><p>变换，就是将时间序列中的对象或这个序列进行加工处理，转换成不同的事件或者事件序列。</p>
<h3 id="u5B9E_u4F8B_u4EE3_u7801"><a href="#u5B9E_u4F8B_u4EE3_u7801" class="headerlink" title="实例代码"></a>实例代码</h3><h4 id="map_28_29"><a href="#map_28_29" class="headerlink" title="map()"></a>map()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"image/logo.png"</span>)</span><br><span class="line">      .map(<span class="keyword">new</span> Func1&lt;String, Bitmap&gt;() &#123;</span><br><span class="line">          <span class="annotation">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> Bitmap <span class="title">call</span><span class="params">(String filepate)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> getBitmapFromFile(filepate);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .subscribe(<span class="keyword">new</span> Action1&lt;Bitmap&gt;() &#123;</span><br><span class="line">          <span class="annotation">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">              showBitmap(bitmap);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>
<p>可以看到 Fun1和Action1非常接近，区别在于Fun1包装了一个有返回值的方法，Action1包装了一个无返回值的方法.<br>这样就可以把原本的参数类型转化为Bitmap。</p>
<h4 id="flatMap_28_29"><a href="#flatMap_28_29" class="headerlink" title="flatMap()"></a>flatMap()</h4><p>需求1：从一个数据类型Students中，打印出学生名<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Student[] students = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">"TAG"</span>,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Observable.from(students)</span><br><span class="line">        .map(<span class="keyword">new</span> Func1&lt;Student, String&gt;() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> student.getName();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe(subscriber);</span><br></pre></td></tr></table></figure></p>
<p>需求2：从一个数据类型students中，打印出学生选的课程名称，注意：每个学生课程数不为0<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Subscriber&lt;Student&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">                List&lt;String&gt; courses = student.getCourses();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; courses.size(); i++) &#123;</span><br><span class="line">                    String course = courses.get(i);</span><br><span class="line">                    Log.d(<span class="string">"TAG"</span>, course);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Observable.from(students).subscribe(subscriber);</span><br></pre></td></tr></table></figure></p>
<p>需求3：不使用for循环打印课程<br>分析：用map肯定是行的，因为map是一对一转换，现在是要一对多的转化，这时就需要flatmap()了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                Log.i(<span class="string">"TAG"</span>, s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Observable.from(students)</span><br><span class="line">                .flatMap(<span class="keyword">new</span> Func1&lt;Student, Observable&lt;String&gt;&gt;() &#123;</span><br><span class="line">                    <span class="annotation">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">call</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> Observable.from(student.getCourses());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .subscribe(subscriber);</span><br></pre></td></tr></table></figure></p>
<p>注意到flatmap返回的是一个Observal对象，此时不发送这个observal对象，每个observal发送的对象都被汇入同一个Observal,并有这个Observal统一交给subscriber回调方法。</p>
<h2 id="u7EBF_u7A0B_u63A7_u5236_Schedulers"><a href="#u7EBF_u7A0B_u63A7_u5236_Schedulers" class="headerlink" title="线程控制 Schedulers"></a>线程控制 Schedulers</h2><h3 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h3><p>多次切换线程：observeOn()指定的是它之后操作的线程，只要在每个想要切换线程的位置调用observeOn()即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">               .subscribeOn(Schedulers.io())</span><br><span class="line">               .observeOn(Schedulers.newThread())</span><br><span class="line">               .map(map1)<span class="comment">//新线程，有observeOn指定</span></span><br><span class="line">               .observeOn(Schedulers.io())</span><br><span class="line">               .map(map2)  <span class="comment">//io线程，由observeOn指定</span></span><br><span class="line">               .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">               .subscribeOn(subscriber);<span class="comment">//主线程，由observeOn指定</span></span><br></pre></td></tr></table></figure></p>
<h2 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h2><p>至此，对RxJava应该能有个大概的了解了，至少能够了解一些RxJava的基本内容了。然而，一切不讲实际需求的代码教学都是耍流氓，没有一个好的应用场景很难理解RxJava的好处，我看到像大头鬼这些大神也苦于寻找到一个优秀的使用场景，RxJava之路依然艰难。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="RxJava_u7B14_u8BB03"><a href="#RxJava_u7B14_u8BB03" class="headerlink" title="RxJava笔记3"></a>RxJava笔记3</h1><h2 id="u53D8_u6362"><a h]]>
    </summary>
    
      <category term="Android" scheme="http://blog.coryphaei.com/tags/Android/"/>
    
      <category term="RxJava" scheme="http://blog.coryphaei.com/tags/RxJava/"/>
    
      <category term="Basti" scheme="http://blog.coryphaei.com/categories/Basti/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RxJava学习笔记——基础使用方法]]></title>
    <link href="http://blog.coryphaei.com/2015/12/15/RxJava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <id>http://blog.coryphaei.com/2015/12/15/RxJava学习笔记(一)/</id>
    <published>2015-12-15T04:27:20.000Z</published>
    <updated>2016-01-04T13:47:25.000Z</updated>
    <content type="html"><![CDATA[<h1 id="RxJava_u7B14_u8BB01"><a href="#RxJava_u7B14_u8BB01" class="headerlink" title="RxJava笔记1"></a>RxJava笔记1</h1><h2 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h2><p>很早以前就想去学一学RxJava这个既神秘又高大上的库，看过大头鬼的文章，限于自身水平原因一直看的迷迷糊糊晕头转向。刚找到扔物线写的文章，感觉突然茅塞顿开。 <a href="http://gank.io/post/560e15be2dca930e00da1083#toc_5" target="_blank" rel="external">扔物线文章地址</a></p>
<h2 id="RxJava_u662F_u4EC0_u4E48"><a href="#RxJava_u662F_u4EC0_u4E48" class="headerlink" title="RxJava是什么"></a>RxJava是什么</h2><p>一个实现异步操作的库</p>
<h2 id="RxJava_u4F18_u70B9"><a href="#RxJava_u4F18_u70B9" class="headerlink" title="RxJava优点"></a>RxJava优点</h2><p>实现链式调用，逻辑清晰简单</p>
<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><p><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava</a></p>
<p><a href="https://github.com/ReactiveX/RxAndroid" target="_blank" rel="external">RxAndroid</a></p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">'io.reactivex:rxandroid:1.0.1'</span></span><br><span class="line"><span class="keyword">compile</span> <span class="string">'io.reactivex:rxjava:1.0.16'</span></span><br></pre></td></tr></table></figure>
<h2 id="u57FA_u672C_u5B9E_u73B0"><a href="#u57FA_u672C_u5B9E_u73B0" class="headerlink" title="基本实现"></a>基本实现</h2><h3 id="u521B_u5EFA_u89C2_u5BDF_u8005Observer"><a href="#u521B_u5EFA_u89C2_u5BDF_u8005Observer" class="headerlink" title="创建观察者Observer"></a>创建观察者Observer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Observer&lt;String&gt; observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.i(<span class="string">"TAG"</span>,<span class="string">"onCompleted"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                Log.i(<span class="string">"TAG"</span>,s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<p>另外，Observer还有一个抽象类，Subscriber，两者使用方法基本一样，事实上，在subscibe的过程中，Observer也会被转化为一个Subscriber。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">"TAG"</span>,<span class="string">"onCompleted"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">"TAG"</span>,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="u521B_u5EFA_u88AB_u89C2_u5BDF_u8005_Observable"><a href="#u521B_u5EFA_u88AB_u89C2_u5BDF_u8005_Observable" class="headerlink" title="创建被观察者 Observable"></a>创建被观察者 Observable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable observable = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">           <span class="annotation">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">               subscriber.onNext(<span class="string">"Hello"</span>);</span><br><span class="line">               subscriber.onNext(<span class="string">"World"</span>);</span><br><span class="line">               subscriber.onNext(<span class="string">"Android"</span>);</span><br><span class="line">               subscriber.onCompleted();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="u521B_u5EFA_u88AB_u89C2_u5BDF_u8005_u7684_u5176_u4ED6_u65B9_u6CD5"><a href="#u521B_u5EFA_u88AB_u89C2_u5BDF_u8005_u7684_u5176_u4ED6_u65B9_u6CD5" class="headerlink" title="创建被观察者的其他方法"></a>创建被观察者的其他方法</h3><p>除了以上的create()方法，其他还有</p>
<h4 id="just"><a href="#just" class="headerlink" title="just"></a>just</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">just(T...)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable observable = Observable.just(<span class="string">"Hello"</span>,<span class="string">"World"</span>,<span class="string">"Android"</span>);</span><br></pre></td></tr></table></figure>
<p>等价于<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onNext(<span class="string">"Hello"</span>);</span><br><span class="line">onNext(<span class="string">"World"</span>);</span><br><span class="line">onNex(<span class="string">"Android"</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="from"><a href="#from" class="headerlink" title="from"></a>from</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from(T[]);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] words = &#123;<span class="string">"Hello"</span>,<span class="string">"World"</span>,<span class="string">"Android"</span>&#125;;</span><br><span class="line">Observable observable = Observable.from(words);</span><br></pre></td></tr></table></figure>
<p>等价于<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onNext(<span class="string">"Hello"</span>);</span><br><span class="line">onNext(<span class="string">"World"</span>);</span><br><span class="line">onNex(<span class="string">"Android"</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="u8BA2_u9605"><a href="#u8BA2_u9605" class="headerlink" title="订阅"></a>订阅</h3><p>创建完了观察者subscriber或observer和被观察者observal以后，需要将二者绑定<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observal.subscibe(subsciber);</span><br></pre></td></tr></table></figure></p>
<h4 id="u8BA2_u9605_u7684_u5176_u4ED6_u65B9_u6CD5"><a href="#u8BA2_u9605_u7684_u5176_u4ED6_u65B9_u6CD5" class="headerlink" title="订阅的其他方法"></a>订阅的其他方法</h4><p>subscribe()接受不完整定义的回调<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Action1&lt;String&gt; onNextAction = <span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">    <span class="comment">// onNext()</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Action1&lt;Throwable&gt; onErrorAction = <span class="keyword">new</span> Action1&lt;Throwable&gt;() &#123;</span><br><span class="line">    <span class="comment">// onError()</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Error handling</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Action0 onCompletedAction = <span class="keyword">new</span> Action0() &#123;</span><br><span class="line">    <span class="comment">// onCompleted()</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">"completed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动创建 Subscriber ，并使用 onNextAction 来定义 onNext()</span></span><br><span class="line">observable.subscribe(onNextAction);</span><br><span class="line"><span class="comment">// 自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()</span></span><br><span class="line">observable.subscribe(onNextAction, onErrorAction);</span><br><span class="line"><span class="comment">// 自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()</span></span><br><span class="line">observable.subscribe(onNextAction, onErrorAction, onCompletedAction);</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="RxJava_u7B14_u8BB01"><a href="#RxJava_u7B14_u8BB01" class="headerlink" title="RxJava笔记1"></a>RxJava笔记1</h1><h2 id="u5199_u5728_u524D]]>
    </summary>
    
      <category term="Android" scheme="http://blog.coryphaei.com/tags/Android/"/>
    
      <category term="RxJava" scheme="http://blog.coryphaei.com/tags/RxJava/"/>
    
      <category term="Basti" scheme="http://blog.coryphaei.com/categories/Basti/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Travis CI自动构建Hexo静态博客]]></title>
    <link href="http://blog.coryphaei.com/2015/12/11/%E4%BD%BF%E7%94%A8Travis%20CI%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAHexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    <id>http://blog.coryphaei.com/2015/12/11/使用Travis CI自动构建Hexo静态博客/</id>
    <published>2015-12-11T13:34:52.000Z</published>
    <updated>2015-12-14T13:37:03.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>随着现在open source越来越火，更多的人开始注重技术知识的获取。不可否认，目前的信息传播速度非常之快，渠道也非常之多，对于知识获取的整理和理解是很多人都在做的一件事情。在这种情况下更多的人开始选择写博客，把自己认知记录下来，一是为了检验自己对于技术的理解，二是为了让更多的人去从你的博客中获取到有用的信息。</p>
<p>我2014年的时候自己买了域名，用<code>jekyll + GitHub Pages</code>搭建了自己的博客，有兴趣的可以访问我的<a href="http://yeziahehe.com" target="_blank" rel="external">博客</a>。（目前正在考虑换到Hexo，而Coryphaei技术博客就是采用的Hexo）</p>
<h1 id="u6280_u672F"><a href="#u6280_u672F" class="headerlink" title="技术"></a>技术</h1><p>Coryphaei技术博客采用的是<code>Hexo + GitHub Pages + Travis CI</code>的技术方案，实现了多人同时更新博客并且自动化构建。</p>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p><a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>是一款高效、简洁的静态博客框架，目前整个项目都开源在<a href="https://github.com/hexojs/hexo" target="_blank" rel="external">GitHub</a>上。因为部署极其简单，而且不需要数据库的支持，纯静态的模式，使得目前静态博客被越来越多的选择。关注与文章本身，创造出更有价值的文章才是每个写博客的人的初衷。</p>
<p>Hexo是由<a href="nodejs.org">Node.js</a>完成，需要集成Node.js的开发环境，这里不再赘述。接下来开始集成Hexo的开发环境，因为我是OS X，所以一下所有的均是基于OS X环境的搭建教程。</p>
<p>首先，需要配置基本的环境。</p>
<h3 id="cnpm"><a href="#cnpm" class="headerlink" title="cnpm"></a>cnpm</h3><blockquote>
<p>注意：npm因为qiang的原因，经常会出问题，我换成了taobao的cmpn镜像，taobao的cnpm镜像这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。</p>
</blockquote>
<p>安装方式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p>
<h3 id="Hexo_u57FA_u672C_u73AF_u5883"><a href="#Hexo_u57FA_u672C_u73AF_u5883" class="headerlink" title="Hexo基本环境"></a>Hexo基本环境</h3><p>Hexo基本环境的配置，步骤比较简单。</p>
<h4 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install hexo-cli -g</span><br><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<p>启动本地的服务器看下是否安装成功<code>hexo s</code>，浏览器打开<code>http://localhost:4000</code>。</p>
<h4 id="u4E3B_u9898_Next"><a href="#u4E3B_u9898_Next" class="headerlink" title="主题 Next"></a>主题 Next</h4><p>我采用的是<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">Next</a>主题，这个主题是国人写的，因为其简洁的特点，深受大家的喜欢。Next有官方出的<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">使用说明</a>，大家有问题可以先去浏览使用说明。</p>
<p>安装非常简单<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p>
<p>启用 NexT 主题<br>克隆/下载 完成后，打开根目录下的_config.yml，找到<code>theme</code>字段，并将其值更改为<code>next</code>。<br>启动本地的服务器看下是否安装成功<code>hexo s</code>，浏览器打开<code>http://localhost:4000</code>。</p>
<h4 id="u57FA_u672C_u914D_u7F6E_u7684_u4E00_u4E9B_u4FEE_u6539"><a href="#u57FA_u672C_u914D_u7F6E_u7684_u4E00_u4E9B_u4FEE_u6539" class="headerlink" title="基本配置的一些修改"></a>基本配置的一些修改</h4><p>对于博客的基本配置的个性化定制，完全可以参照Next官方出的<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">使用说明</a>，我也附上我的 <a href="https://github.com/Coryphaei/coryphaei.github.io/blob/blog/_config.yml" target="_blank" rel="external">_config.yml</a> 和theme目录下的<a href="https://github.com/Coryphaei/coryphaei.github.io/blob/blog/themes/next/_config.yml" target="_blank" rel="external">themes/next/_config.yml</a>供大家参考。</p>
<p>到目前为止，整个Hexo的博客就搭建完毕。</p>
<h2 id="GitHub_Pages"><a href="#GitHub_Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h2><p>有关于GitHub Pages的问题，网上教程太多，大家可以自行google，这边就不在赘述。</p>
<h2 id="Travis_CI"><a href="#Travis_CI" class="headerlink" title="Travis CI"></a>Travis CI</h2><p>目前，自动化构建、持续集成的理念在整个计算行业非常的流行，大家更愿意去使用自动化代替手动，从而提高效率。</p>
<p><code>持续集成</code>的概念</p>
<blockquote>
<p>持续集成是一种软件开发实践。在持续集成中，团队成员频繁集成他们的工作成果，每人每天可能集成一次，甚至多次。每次集成会经过自动构建（包括自动测试）的检验，以尽快发现集成错误。许多团队发现这种方法可以显著减少集成引起的问题，并可以加快团队合作软件开发的速度。</p>
</blockquote>
<p>自动构建工具则是持续集成的一种出色实践。代码提交后，由软件自动完成代码的测试、构建，并将过程中状态与构建物产出才是持续集成的意义。</p>
<p><a href="https://travis-ci.org/" target="_blank" rel="external">Travis CI</a>就是一个在线的、分布式的持续集成服务，用来构建及测试在GitHub托管的代码。利用Travis CI 会在每一次push后生成一个虚拟机来执行事先安排好的自动构建任务，从来进行发布。</p>
<h3 id="u4E3A_u4EC0_u4E48_u4F7F_u7528"><a href="#u4E3A_u4EC0_u4E48_u4F7F_u7528" class="headerlink" title="为什么使用"></a>为什么使用</h3><p>Travis CI本身已经是很好的自动构建的工具，而这里使用的原因，本质上是因为Hexo本身并不能进行多人合作。Hexo的<code>hexo generate</code>和<code>hexo deploy</code>会自动渲染并提交到GitHub上，所以当你从别的电脑上clone的时候，clone下来的是渲染好的html的文章。就算我在两个电脑上同时搭建了环境，但是每次渲染的时候只会渲染本地的markdown文章，依然不能进行同步。有些人选择了使用百度云进行同步，每次写之前下载下来并覆盖，就能进行同步。不否认，这个方法对于一个人写博客，在工作和家的电脑还算是比较方便的，因为始终是一个人进行操作。而我们的博客是多人共同写的，所以说会存在各种冲突问题，于是想到了用Travis CI。</p>
<h3 id="u539F_u7406"><a href="#u539F_u7406" class="headerlink" title="原理"></a>原理</h3><p><img src="http://7xp57v.com1.z0.glb.clouddn.com/coryphaei/travis-hexo-flowing.png" alt="travis-hexo-flowing"></p>
<blockquote>
<p>图片引用自v2cc的<a href="http://v2cc.github.io/2015/09/02/unbelievable-workflow-autodeploy-hexo-by-travis/" target="_blank" rel="external">博客</a>，并且其对于流程的讲解也对我产生了很大的帮助，非常感谢。</p>
</blockquote>
<p>分析下思路：<br>前提：我们在之前博客搭建的repo下面，新建一个blog的分支，这个分支用来进行环境代码的备份，并且配置出<code>.travis.yml</code>进行自动化构建。</p>
<h4 id="User_-_push_-_26gt_3B_branch_blog"><a href="#User_-_push_-_26gt_3B_branch_blog" class="headerlink" title="User - push -&gt; branch blog"></a>User - push -&gt; branch blog</h4><p>将代码push到在GitHub上的博客中的blog分支。</p>
<h4 id="Dev_repo_-_sync_-_26gt_3B_Travis_CI"><a href="#Dev_repo_-_sync_-_26gt_3B_Travis_CI" class="headerlink" title="Dev repo - sync -&gt; Travis CI"></a>Dev repo - sync -&gt; Travis CI</h4><p>在branch blog中配置<code>.travis.yml</code>文件，在Travis CI中开启branch blog的同步开关，并启用<code>Build only if .travis.yml is present</code>项，这样能在repo中有多个branch时，让Travis CI只构建放置了<code>.travis.yml</code>文件的branch。</p>
<h4 id="Travis_CI_-_build_and_push_-_26gt_3B_Pages_repo"><a href="#Travis_CI_-_build_and_push_-_26gt_3B_Pages_repo" class="headerlink" title="Travis CI - build and push -&gt; Pages repo"></a>Travis CI - build and push -&gt; Pages repo</h4><p>Travis CI 的自动化构建完全依靠唯一的<code>.travis.yml</code>脚本文件。需要在此文件中添加构建环境、构建Hexo、生成博客及后续push到Pages repo的全部脚本。</p>
<ul>
<li><p>生成SSH Key<br>要做到Travis CI向Pages repo自动推送就必须用到Github SSH Key，这样做的目的是免去Hexo部署时候输入密码的步骤。生成SSH Key的操作参照GitHub的官网即可：<a href="https://help.github.com/articles/generating-ssh-keys/" target="_blank" rel="external">Github SSH Key</a>。<br>这样会得到<code>id_rsa.pub</code>和<code>id_rsa</code>两个秘钥，我们将<code>id_rsa.pub</code>添加到了github，下面要加密<code>id_rsa</code>这个私钥并且上传到Travis。</p>
<blockquote>
<p>注意：这个SSH key不应该是你账号的全局SSH Key，这样Travis CI就获得了你所有代码库的提交权限。仅仅只需要把SSH Key添加到当前repo的setting中的key下面即可。</p>
</blockquote>
</li>
<li><p>Travis CI 环境</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cp ~/.ssh/id_rsa / <span class="comment">#将上一步得到的`id_rsa`复制到根目录下</span></span><br><span class="line">$ vim .travis.yml <span class="comment">#创建.travis.yml</span></span><br><span class="line">$ gem install travis <span class="comment">#安装Travis CI</span></span><br><span class="line">$ travis login --auto <span class="comment">#登录Travis CI，需要输入GitHub的账号密码</span></span><br><span class="line">$ travis encrypt-file ssh_key --add <span class="comment">#加密私钥并上传至Travis</span></span><br></pre></td></tr></table></figure>
<p>生成加密过得新秘钥<code>id_rsa.enc</code>, 并自动将branch blog中git的信息及解密秘钥的相关信息添加到<code>.travis.yml</code>中。然后手动删除私钥文件<code>id_rsa</code>， 以保证代码仓库的安全。</p>
</li>
<li><p>SSH的设置<br>在当前目录下新建文件<code>ssh_config</code>，内容为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  User git</span><br><span class="line">  StrictHostKeyChecking no</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa</span><br><span class="line">  IdentitiesOnly yes</span><br></pre></td></tr></table></figure>
<p>修改<code>.travis.yml</code>中的命令，指定openssl解密后的生成位置，xxxxxxxxxx部分就是你的解密参数，不要去改动它。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- openssl aes-<span class="number">256</span>-cbc -K <span class="variable">$encrypted_xxxxxxxxxx_key</span> -iv <span class="variable">$encrypted_xxxxxxxxxx_iv</span></span><br><span class="line">  -in travis.enc -out ~/.ssh/id_rsa <span class="operator">-d</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改目录权限<br>紧接着在<code>.travis.yml</code>中修改目录权限</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- chmod <span class="number">600</span> ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
</li>
<li><p>将密钥加入系统<br>紧接着在<code>.travis.yml</code>中将密钥加入系统</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="built_in">eval</span> $(ssh-agent)</span><br><span class="line">- ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改git信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- cp ssh_config ~/.ssh/config</span><br><span class="line">- git config --global user.name <span class="string">"username"</span></span><br><span class="line">- git config --global user.email username@example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加分支信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">  - blog</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置Hexo</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">install:</span><br><span class="line">- npm install hexo-cli -g</span><br><span class="line">- npm install hexo --save</span><br><span class="line">- npm install</span><br><span class="line"></span><br><span class="line">script:</span><br><span class="line">- hexo clean</span><br><span class="line">- hexo d</span><br><span class="line">- hexo g</span><br></pre></td></tr></table></figure>
<p>这样就完成了<code>.travis.yml</code>的设置，这里是我的源文件<a href="https://github.com/Coryphaei/coryphaei.github.io/blob/blog/.travis.yml" target="_blank" rel="external">.travis.yml</a>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">language: node_js</span><br><span class="line">node_js:</span><br><span class="line">- <span class="string">'0.12'</span></span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">  - blog</span><br><span class="line">before_install:</span><br><span class="line">- openssl aes-<span class="number">256</span>-cbc -K <span class="variable">$encrypted_b83a281ef741_key</span> -iv <span class="variable">$encrypted_b83a281ef741_iv</span></span><br><span class="line">  -in id_rsa.enc -out ~/.ssh/id_rsa <span class="operator">-d</span></span><br><span class="line">- chmod <span class="number">600</span> ~/.ssh/id_rsa</span><br><span class="line">- <span class="built_in">eval</span> $(ssh-agent)</span><br><span class="line">- ssh-add ~/.ssh/id_rsa</span><br><span class="line">- cp ssh_config ~/.ssh/config</span><br><span class="line">- git config --global user.name <span class="string">"叶帆"</span></span><br><span class="line">- git config --global user.email yeziahehe@gmail.com</span><br><span class="line">- git <span class="built_in">clone</span> -b master git@github.com:Coryphaei/coryphaei.github.io.git .deploy_git</span><br><span class="line">install:</span><br><span class="line">- npm install hexo-cli -g</span><br><span class="line">- npm install</span><br><span class="line">- npm install hexo-generator-feed --save</span><br><span class="line">- npm install hexo-deployer-git --save</span><br><span class="line">script:</span><br><span class="line">- hexo clean</span><br><span class="line">- hexo g</span><br><span class="line">- hexo g</span><br><span class="line">- hexo d</span><br></pre></td></tr></table></figure>
<p>这个时候应该将其push到blog分支。</p>
<blockquote>
<p>注意，要删除themes/next/.git文件，否则会导致主题传不上去，渲染后首页空白的问题。</p>
</blockquote>
</li>
</ul>
<h4 id="View_the_pages"><a href="#View_the_pages" class="headerlink" title="View the pages"></a>View the pages</h4><p>打开首页，就能看到已经发布的最新博客。</p>
<h1 id="u95EE_u9898"><a href="#u95EE_u9898" class="headerlink" title="问题"></a>问题</h1><p>上述的所有步骤完成后，应该就已经成功了。我这边列举下我遇到的一些问题，希望能帮到大家。大家有任何问题也可以直接评论，我会第一时间回复。</p>
<ul>
<li><p><code>.travis.yml</code>中的注释问题<br><img src="http://7xp57v.com1.z0.glb.clouddn.com/coryphaei/travis_yml_comment.png" alt="travis_yml_comment"><br>一开始的时候我在<code>.travis.yml</code>中的注释用的是<code>//</code>，结果一直导致<code>missing config</code>。后来才知道YAML中注释应该用<code>#</code>。</p>
</li>
<li><p>首页无内容<br>一开始的时候我的首页一片空白，index.html中也是空的，原因就是因为主题Next是从GitHub上clone下来的，里面会存在<code>.git</code>文件，所以push到blog分支的时候千万要注意删除掉next文件夹中的<code>.git</code>文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog/themes/next <span class="comment">#到next主题文件夹下</span></span><br><span class="line">ls <span class="operator">-a</span> <span class="comment">#显示所有文件</span></span><br><span class="line">rm .git <span class="comment">#删除.git文件</span></span><br><span class="line">ls <span class="operator">-a</span> <span class="comment">#确认删除</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>next主题会导致首页只显示最新的文章<br>很多人遇到发布后首页只显示最新的一篇文章，next主题<a href="https://github.com/iissnan/hexo-theme-next/issues/535" target="_blank" rel="external">issue</a>中也有提到这个。<br>解决办法就是<code>hexo g</code>命令做两遍，这个也是为什么我<code>.travis.yml</code>中的Hexo配置命令写了两遍的原因。被这个问题纠缠了很久，希望写出来能帮到大家，如果你没有问题就不需要在<code>.travis.yml</code>中写两遍命令。</p>
</li>
</ul>
<h1 id="u7ED3_u8BED"><a href="#u7ED3_u8BED" class="headerlink" title="结语"></a>结语</h1><p>这个是我搭建这个博客写的第一篇文章，我也发现我这次解决问题会去弄个明白，回想之前写的博客，其实干货真的很少，知识也很肤浅，这次搭建博客–发现问题–解决问题给了我很好的体验，也让我学到了很多，我会尽可能的去写很多的干货去和大家分享！共勉！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>随着现在open source越来越火，更多的人开始注重技术知识的获取。不可否认，目前的信息传播速度非常]]>
    </summary>
    
      <category term="Travis CI" scheme="http://blog.coryphaei.com/tags/Travis-CI/"/>
    
      <category term="hexo" scheme="http://blog.coryphaei.com/tags/hexo/"/>
    
      <category term="叶帆" scheme="http://blog.coryphaei.com/categories/%E5%8F%B6%E5%B8%86/"/>
    
  </entry>
  
</feed>
